{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/ponkis01/BusinessAnalytics/blob/main/GoogleColab_code\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "f7d2f912-4bfc-4be4-b1dd-71da0c18195b",
      "metadata": {
        "id": "f7d2f912-4bfc-4be4-b1dd-71da0c18195b"
      },
      "source": [
        "# Cleaning"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f0587b3b-d0b5-4a03-95b9-806ba0958801",
      "metadata": {
        "id": "f0587b3b-d0b5-4a03-95b9-806ba0958801",
        "outputId": "d34754e2-97ff-4769-9a41-a0d321154dab",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 329
        }
      },
      "outputs": [
        {
          "output_type": "error",
          "ename": "FileNotFoundError",
          "evalue": "[Errno 2] No such file or directory: '/content/WA_Fn-UseC_-HR-Employee-Attrition.xls'",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
            "\u001b[0;32m<ipython-input-1-b7ab19b17b08>\u001b[0m in \u001b[0;36m<cell line: 6>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      4\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m \u001b[0;31m# Importieren des Datensatzes\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 6\u001b[0;31m \u001b[0mdf\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mpd\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mread_csv\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"/content/WA_Fn-UseC_-HR-Employee-Attrition.xls\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
            "\u001b[0;32m/usr/local/lib/python3.10/dist-packages/pandas/io/parsers/readers.py\u001b[0m in \u001b[0;36mread_csv\u001b[0;34m(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend)\u001b[0m\n\u001b[1;32m   1024\u001b[0m     \u001b[0mkwds\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mupdate\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkwds_defaults\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1025\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1026\u001b[0;31m     \u001b[0;32mreturn\u001b[0m \u001b[0m_read\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfilepath_or_buffer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mkwds\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1027\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1028\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.10/dist-packages/pandas/io/parsers/readers.py\u001b[0m in \u001b[0;36m_read\u001b[0;34m(filepath_or_buffer, kwds)\u001b[0m\n\u001b[1;32m    618\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    619\u001b[0m     \u001b[0;31m# Create the parser.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 620\u001b[0;31m     \u001b[0mparser\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mTextFileReader\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfilepath_or_buffer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwds\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    621\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    622\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0mchunksize\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0miterator\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.10/dist-packages/pandas/io/parsers/readers.py\u001b[0m in \u001b[0;36m__init__\u001b[0;34m(self, f, engine, **kwds)\u001b[0m\n\u001b[1;32m   1618\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1619\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mhandles\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mIOHandles\u001b[0m \u001b[0;34m|\u001b[0m \u001b[0;32mNone\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1620\u001b[0;31m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_engine\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_make_engine\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mengine\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1621\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1622\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0mclose\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.10/dist-packages/pandas/io/parsers/readers.py\u001b[0m in \u001b[0;36m_make_engine\u001b[0;34m(self, f, engine)\u001b[0m\n\u001b[1;32m   1878\u001b[0m                 \u001b[0;32mif\u001b[0m \u001b[0;34m\"b\"\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mmode\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1879\u001b[0m                     \u001b[0mmode\u001b[0m \u001b[0;34m+=\u001b[0m \u001b[0;34m\"b\"\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1880\u001b[0;31m             self.handles = get_handle(\n\u001b[0m\u001b[1;32m   1881\u001b[0m                 \u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1882\u001b[0m                 \u001b[0mmode\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.10/dist-packages/pandas/io/common.py\u001b[0m in \u001b[0;36mget_handle\u001b[0;34m(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)\u001b[0m\n\u001b[1;32m    871\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mioargs\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mencoding\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0;34m\"b\"\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mioargs\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmode\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    872\u001b[0m             \u001b[0;31m# Encoding\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 873\u001b[0;31m             handle = open(\n\u001b[0m\u001b[1;32m    874\u001b[0m                 \u001b[0mhandle\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    875\u001b[0m                 \u001b[0mioargs\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmode\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] No such file or directory: '/content/WA_Fn-UseC_-HR-Employee-Attrition.xls'"
          ]
        }
      ],
      "source": [
        "import pandas as pd\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Importieren des Datensatzes\n",
        "df = pd.read_csv(\"/content/WA_Fn-UseC_-HR-Employee-Attrition.xls\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "87403a5c-86c5-4cc3-9697-df276b8459d4",
      "metadata": {
        "id": "87403a5c-86c5-4cc3-9697-df276b8459d4"
      },
      "outputs": [],
      "source": [
        "# Einstellung um den ganzen datensatz zu sehen\n",
        "pd.set_option('display.max_columns', None)\n",
        "pd.set_option('display.expand_frame_repr', False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c78f1898-066b-42db-bc20-a87dd603d3c5",
      "metadata": {
        "collapsed": true,
        "id": "c78f1898-066b-42db-bc20-a87dd603d3c5"
      },
      "outputs": [],
      "source": [
        "# Nach fehlenden Daten suchen\n",
        "df.isnull().sum()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "085a683c-8281-48ba-a1a3-1f424570ea26",
      "metadata": {
        "collapsed": true,
        "id": "085a683c-8281-48ba-a1a3-1f424570ea26"
      },
      "outputs": [],
      "source": [
        "import seaborn as sns\n",
        "\n",
        "# Identifizieren ob es eine Korrelation zwischen den verschiedenen Bezahlungen gibt gibt.\n",
        "# Falls es diese gibt könnte man die Bezahlung auch mit einer Variablen beschreiben um das Modell leichter interpretierbar zu machen.\n",
        "df2 = df[[\"DailyRate\", \"HourlyRate\", \"MonthlyRate\", \"MonthlyIncome\"]]\n",
        "correlation_matrix = df2.corr()\n",
        "plt.figure(figsize=(8, 6))\n",
        "sns.heatmap(correlation_matrix, annot=True, cmap=\"coolwarm\", fmt=\".2f\")\n",
        "plt.title(\"Correlation Matrix\")\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "73a118c9-bcdb-4a1f-8ad1-f98632accc22",
      "metadata": {
        "collapsed": true,
        "id": "73a118c9-bcdb-4a1f-8ad1-f98632accc22"
      },
      "outputs": [],
      "source": [
        "# Identifizieren ob es eine Korrelation zwischen YearsWithCurrManager, YearsInCurrentRole und YearsAtCompany gibt.\n",
        "# Da YearsAtCompany predicted wird wollen wir andere ähnlche und stark korrelierende Variablen löschen.\n",
        "\n",
        "df3 = df[[\"YearsWithCurrManager\", \"YearsInCurrentRole\", \"YearsAtCompany\"]]\n",
        "correlation_matrix = df3.corr()\n",
        "plt.figure(figsize=(8, 6))\n",
        "sns.heatmap(correlation_matrix, annot=True, cmap=\"coolwarm\", fmt=\".2f\")\n",
        "plt.title(\"Correlation Matrix\")\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b66153ad-babc-4d9f-af31-c9378acfbfd0",
      "metadata": {
        "id": "b66153ad-babc-4d9f-af31-c9378acfbfd0"
      },
      "outputs": [],
      "source": [
        "from sklearn.model_selection import train_test_split\n",
        "from sksurv.util import Surv\n",
        "\n",
        "# Droppen von Variable die nicht genutzt werden können\n",
        "df = df.drop(['EmployeeCount', 'EmployeeNumber', 'StandardHours', 'YearsWithCurrManager', 'YearsInCurrentRole'], axis=1)\n",
        "\n",
        "#Die Daten müssen verwertbar sein d.h. fehlerfrei und einheitlich formatiert sein.\n",
        "#Unnötige Daten werden entfernt.\n",
        "#Aufteilung in kategorische und numerische Spalten um diese später besser verarbeiten zu können.\n",
        "\n",
        "# Konvertieren von gewissen Variablen zu kathegorischen Variablen\n",
        "categorical_columns = [\n",
        "    'Attrition', 'BusinessTravel', 'Department', 'Education', 'Gender',\n",
        "    'EducationField', 'JobRole', 'MaritalStatus', 'Over18', 'OverTime',\n",
        "    'StockOptionLevel', 'EnvironmentSatisfaction', 'JobInvolvement',\n",
        "    'JobSatisfaction', 'PerformanceRating', 'RelationshipSatisfaction',\n",
        "    'WorkLifeBalance'\n",
        "]\n",
        "df[categorical_columns] = df[categorical_columns].astype('category')\n",
        "\n",
        "# Skalieren der numerischen Werte\n",
        "variables_to_scale = [\n",
        "    'Age', 'DailyRate', 'DistanceFromHome', 'HourlyRate', 'MonthlyIncome',\n",
        "    'MonthlyRate', 'NumCompaniesWorked', 'PercentSalaryHike',\n",
        "    'TotalWorkingYears', 'TrainingTimesLastYear', 'YearsSinceLastPromotion'\n",
        "]\n",
        "df_mean = df[variables_to_scale].mean()\n",
        "df_std = df[variables_to_scale].std()\n",
        "df[variables_to_scale] = (df[variables_to_scale] - df_mean) / df_std\n",
        "\n",
        "# Encoden der kategorischen Variablen\n",
        "# Hier weisen wir jedem kategorischen Wert eine Zahl zu. Das erlaubt den Modellen leichter mit den Variablen zu arbeiten.\n",
        "from sklearn.preprocessing import LabelEncoder\n",
        "columns_to_encode = ['BusinessTravel', 'Department',\n",
        "                     'EducationField', 'Gender', 'JobRole',\n",
        "                     'MaritalStatus', 'OverTime', 'Over18', 'Attrition']\n",
        "label_encoder = LabelEncoder()\n",
        "for col in columns_to_encode:\n",
        "    df[col] = label_encoder.fit_transform(df[col])\n",
        "    df[col] = df[col].astype('category')\n",
        "\n",
        "\n",
        "# Strukturieren das Datensatzes in X und y (y Werte werden in einen strukturierten Array umgewandelt (Survival, Time)\n",
        "event_column = df['Attrition'].astype(int)\n",
        "time_column = df['YearsAtCompany']\n",
        "\n",
        "# da wir eine Survival analyse machen ist unser y Datensatz ein Array mit Überleben(ja/nein) und Überlebenszeit.\n",
        "survival_data = Surv.from_arrays(event=event_column, time=time_column)\n",
        "X = df.drop(['Attrition', 'YearsAtCompany'], axis=1)\n",
        "y = survival_data\n",
        "\n",
        "# Train und Test Aufteilung\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=12)\n",
        "\n",
        "y_train_event = y_train['event']\n",
        "y_train_time = y_train['time']\n",
        "y_test_event = y_test['event']\n",
        "y_test_time = y_test['time']"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "56e216b2-1cff-4628-b757-178f7bd3981d",
      "metadata": {
        "id": "56e216b2-1cff-4628-b757-178f7bd3981d"
      },
      "source": [
        "# XGBoost"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b2cf7fed-38a6-4554-81af-ede2d3841b54",
      "metadata": {
        "collapsed": true,
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "b2cf7fed-38a6-4554-81af-ede2d3841b54",
        "outputId": "89768309-a130-4f84-9115-2f6bf0a58ecc"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Concordance Index (Training): 0.879\n",
            "Concordance Index (Testing): 0.805\n"
          ]
        }
      ],
      "source": [
        "import xgboost as xgb\n",
        "from sksurv.metrics import concordance_index_censored\n",
        "\n",
        "# Initialisieren des Modells\n",
        "xgb_model = xgb.XGBRegressor(\n",
        "    enable_categorical=True,\n",
        "    # Das objective erlaubt uns aus dem standart XGB Modell eine Cox Survival Analyse zu machen.\n",
        "    objective='survival:cox',\n",
        ")\n",
        "xgb_model.fit(X_train, y_train_time, sample_weight=y_train_event)\n",
        "\n",
        "# Vorhersagen der Train und Test Risikowerte\n",
        "xgb_risk_scores_train = xgb_model.predict(X_train)\n",
        "xgb_risk_scores_test = xgb_model.predict(X_test)\n",
        "\n",
        "# Berechnen des Concordance Indexes\n",
        "xgb_c_index_train = concordance_index_censored(y_train_event, y_train_time, xgb_risk_scores_train)[0]\n",
        "xgb_c_index_test = concordance_index_censored(y_test_event, y_test_time, xgb_risk_scores_test)[0]\n",
        "\n",
        "print(f\"Concordance Index (Training): {xgb_c_index_train:.3f}\")\n",
        "print(f\"Concordance Index (Testing): {xgb_c_index_test:.3f}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "8c313d6c-7e3c-469d-b800-71eaf1ff281d",
      "metadata": {
        "id": "8c313d6c-7e3c-469d-b800-71eaf1ff281d"
      },
      "source": [
        "Der Concordance Index zeigt uns an, wie gut das Modell die Reihenfolge der \"Überlebenszeiten\" der verschiedenen Angestellten vorhersagt. Er sagt uns, wie gut das Modell in der Lage ist, für zwei beliebig ausgewählte Individuen die Rangfolge ihrer erwarteten Überlebenszeiten oder Risiken korrekt vorherzusagen. Ein Wert von 0.5 würde also aussagen dass das Modell keine Predictive Power hat und ein Wert von 1 dass das Modell alle Reihenfolgen richtig verhersagt."
      ]
    },
    {
      "cell_type": "markdown",
      "id": "08dc0443-a477-44ed-9edd-24a8a9f01535",
      "metadata": {
        "id": "08dc0443-a477-44ed-9edd-24a8a9f01535"
      },
      "source": [
        "# XGBSE"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b89614d8-831b-483f-af98-084d81331f04",
      "metadata": {
        "collapsed": true,
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "b89614d8-831b-483f-af98-084d81331f04",
        "outputId": "438851ed-bfa6-4074-cfa4-8cb4f6fcacab"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "/usr/local/lib/python3.10/dist-packages/xgbse/non_parametric.py:61: FutureWarning: DataFrame.fillna with 'method' is deprecated and will raise in a future version. Use obj.ffill() or obj.bfill() instead.\n",
            "  return pd.DataFrame(C_exp).fillna(method=\"bfill\").fillna(method=\"ffill\").values\n",
            "/usr/local/lib/python3.10/dist-packages/xgbse/non_parametric.py:61: FutureWarning: DataFrame.fillna with 'method' is deprecated and will raise in a future version. Use obj.ffill() or obj.bfill() instead.\n",
            "  return pd.DataFrame(C_exp).fillna(method=\"bfill\").fillna(method=\"ffill\").values\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Concordance Index (Training): 0.907\n",
            "Concordance Index (Testing): 0.772\n"
          ]
        }
      ],
      "source": [
        "from xgbse import XGBSEKaplanNeighbors\n",
        "from xgbse.converters import convert_to_structured\n",
        "from xgbse.metrics import concordance_index\n",
        "\n",
        "# Initialisieren des Modells\n",
        "xgbse_model = XGBSEKaplanNeighbors(enable_categorical = True)\n",
        "xgbse_model.fit(X_train, y_train)\n",
        "\n",
        "# Vorhersagen der Train und Test Risikowerte\n",
        "xgb_risk_scores_train = xgbse_model.predict(X_train)\n",
        "xgb_risk_scores_test = xgbse_model.predict(X_test)\n",
        "\n",
        "# Berechnen des Concordance Indexes\n",
        "xgb_c_index_train = concordance_index(y_train, xgb_risk_scores_train)\n",
        "xgb_c_index_test = concordance_index(y_test, xgb_risk_scores_test)\n",
        "\n",
        "print(f\"Concordance Index (Training): {xgb_c_index_train:.3f}\")\n",
        "print(f\"Concordance Index (Testing): {xgb_c_index_test:.3f}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "fdbca0ec-5c8b-4894-b9de-67d35909faac",
      "metadata": {
        "id": "fdbca0ec-5c8b-4894-b9de-67d35909faac"
      },
      "source": [
        "# Random Survival Forest"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "Das RSF Modell ist eine statistische Methode, welche Ereigniszeiten modelliert und versucht die Dauer bis zum eintreffen des Ereignisses vorherzusagen. Es basiert auf Bootstrap-Sampling (Datensatz ins zufällige Teile splitten), Baumerstellung (Baum splittet Daten basierend auf Überlebensinformationen und speichert diese in den Blättern) und Aggregation (Überlebenswahrscheinlichkeit eines neuen Datenpunkts wird als Durchschnitt der Vorhersagen aus allen Bäumen berechnet).\n",
        "\\\n",
        "Im Endeffekt sagt der Random Survival Forest für jede Beobachtung eine Hazard-Kurve vorher. Diese kann in eine Survival-Kurve umgewandelt werden, die die Wahrscheinlichkeit angibt, dass ein Individuum über einen bestimmten Zeitpunkt hinaus überlebt."
      ],
      "metadata": {
        "id": "csiUWuI8q99y"
      },
      "id": "csiUWuI8q99y"
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "3e3d1e52-c195-412a-b4c9-d8d072c7bcd0",
      "metadata": {
        "collapsed": true,
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "3e3d1e52-c195-412a-b4c9-d8d072c7bcd0",
        "outputId": "4ea4c6c6-f092-455e-cafd-3defa37b4f80"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Concordance Index (Train): 0.972\n",
            "Concordance Index (Test): 0.834\n"
          ]
        }
      ],
      "source": [
        "from sksurv.ensemble import RandomSurvivalForest\n",
        "from sksurv.util import Surv\n",
        "\n",
        "# Trainieren des Modells\n",
        "rsf_model = RandomSurvivalForest()\n",
        "rsf_model.fit(X_train, y_train)\n",
        "\n",
        "# Vorhersagen der Trainings- und Testdaten\n",
        "rsf_risk_scores_train = rsf_model.predict(X_train)\n",
        "rsf_risk_scores_test = rsf_model.predict(X_test)\n",
        "\n",
        "# Berechnen des C Indexes\n",
        "rsf_c_index_train = concordance_index_censored(y_train['event'], y_train['time'], rsf_risk_scores_train)[0]\n",
        "rsf_c_index_test = concordance_index_censored(y_test['event'], y_test['time'], rsf_risk_scores_test)[0]\n",
        "\n",
        "print(f\"Concordance Index (Training): {rsf_c_index_train:.3f}\")\n",
        "print(f\"Concordance Index (Testing): {rsf_c_index_test:.3f}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "cda10070-85f0-4f17-86dc-c97cbbd18d13",
      "metadata": {
        "id": "cda10070-85f0-4f17-86dc-c97cbbd18d13"
      },
      "source": [
        "Der Random Survival Forest schneidet ohne Tuning am besten von allen Modellen ab. Deswegen haben wir uns entschieden, mit diesem Modell weiterzuarbeiten."
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "# Tuning"
      ],
      "metadata": {
        "id": "satb56U9rFhX"
      },
      "id": "satb56U9rFhX"
    },
    {
      "cell_type": "markdown",
      "source": [
        "Da GridSearchCV weder nach dem C-Index optimieren kann noch strukturierte Arrays als Zielvariablen unterstützt, müssen wir das Modell mit Hyperopt manuell optimieren.\n"
      ],
      "metadata": {
        "id": "Z3qW_1mBrB_D"
      },
      "id": "Z3qW_1mBrB_D"
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "a42de75d-c007-4689-9cb7-2ae7c03ef726",
      "metadata": {
        "collapsed": true,
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "a42de75d-c007-4689-9cb7-2ae7c03ef726",
        "outputId": "a9ee1ed2-5688-4382-fcda-81cce769b5b1"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "100%|██████████| 50/50 [17:01<00:00, 20.42s/trial, best loss: -0.8704109082756183]\n"
          ]
        }
      ],
      "source": [
        "from hyperopt import fmin, tpe, hp, Trials\n",
        "from sksurv.metrics import concordance_index_censored\n",
        "from sksurv.ensemble import RandomSurvivalForest\n",
        "from sklearn.model_selection import KFold\n",
        "import numpy as np\n",
        "\n",
        "# Zielfunktion erstellen\n",
        "def objective(params):\n",
        "    # Erstellen des Random Survival Forest mit variablen Parametern\n",
        "    model = RandomSurvivalForest(\n",
        "        n_estimators=int(params['n_estimators']),\n",
        "        max_depth=int(params['max_depth']) if params['max_depth'] is not None else None,\n",
        "        min_samples_split=int(params['min_samples_split']),\n",
        "        min_samples_leaf=int(params['min_samples_leaf']),\n",
        "        max_features=params['max_features'],\n",
        "        random_state=12\n",
        "    )\n",
        "\n",
        "    # Cross Validation\n",
        "    kf = KFold(n_splits=5, shuffle=True, random_state=12)\n",
        "    c_index_scores = []\n",
        "\n",
        "    for train_index, test_index in kf.split(X_train):\n",
        "        X_train_cv, X_test_cv = X.iloc[train_index], X.iloc[test_index]\n",
        "        y_train_cv, y_test_cv = y[train_index], y[test_index]\n",
        "\n",
        "        model.fit(X_train_cv, y_train_cv)\n",
        "        predictions = model.predict(X_test_cv)\n",
        "\n",
        "        c_index = concordance_index_censored(y_test_cv['event'], y_test_cv['time'], predictions)[0]\n",
        "        c_index_scores.append(c_index)\n",
        "\n",
        "    # Durchschnitt des Konkordanz-Index für alle CV Folds berechnen\n",
        "    mean_c_index = np.mean(c_index_scores)\n",
        "\n",
        "    # Hyperopt minimiert die Zielfunktion, also geben wir den negativen C-Index an\n",
        "    return -mean_c_index\n",
        "\n",
        "# Hyperparametergrid erstellen\n",
        "space = {\n",
        "    'n_estimators': hp.choice('n_estimators', [100, 200, 500, 1000]),\n",
        "    'max_depth': hp.choice('max_depth', [None, 10, 20, 30, 50]),\n",
        "    'min_samples_split': hp.quniform('min_samples_split', 2, 20, 1),\n",
        "    'min_samples_leaf': hp.quniform('min_samples_leaf', 1, 10, 1),\n",
        "    'max_features': hp.choice('max_features', ['sqrt', 'log2', None])\n",
        "}\n",
        "\n",
        "# Optimierung starten\n",
        "trials = Trials()\n",
        "best = fmin(\n",
        "    fn=objective,\n",
        "    space=space,\n",
        "    algo=tpe.suggest,\n",
        "    max_evals=50,\n",
        "    trials=trials\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c85f8fee-0c67-4b73-9928-6b3de1340f22",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "c85f8fee-0c67-4b73-9928-6b3de1340f22",
        "outputId": "e07003c4-f6a8-4412-9237-8ca2ce8268b1"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "{'bootstrap': True,\n",
              " 'low_memory': False,\n",
              " 'max_depth': None,\n",
              " 'max_features': 'log2',\n",
              " 'max_leaf_nodes': None,\n",
              " 'max_samples': None,\n",
              " 'min_samples_leaf': 1,\n",
              " 'min_samples_split': 2,\n",
              " 'min_weight_fraction_leaf': 0.0,\n",
              " 'n_estimators': 1000,\n",
              " 'n_jobs': None,\n",
              " 'oob_score': False,\n",
              " 'random_state': 12,\n",
              " 'verbose': 0,\n",
              " 'warm_start': False}"
            ]
          },
          "metadata": {},
          "execution_count": 17
        }
      ],
      "source": [
        "# Fitting des Modells mit optimalen Prametern\n",
        "optimal_model = RandomSurvivalForest(\n",
        "    n_estimators=[100, 200, 500, 1000][best['n_estimators']],\n",
        "    max_depth=[None, 10, 20, 30, 50][best['max_depth']],\n",
        "    min_samples_split=int(best['min_samples_split']),\n",
        "    min_samples_leaf=int(best['min_samples_leaf']),\n",
        "    max_features=['sqrt', 'log2', None][best['max_features']],\n",
        "    random_state=12\n",
        ")\n",
        "optimal_model.fit(X_train, y_train)\n",
        "optimal_model.get_params()"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "# Evaluieren des Modells"
      ],
      "metadata": {
        "id": "fvAHhc48rJCi"
      },
      "id": "fvAHhc48rJCi"
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "dc984b11-ce8b-4a50-ba0e-47c3371ef9b6",
      "metadata": {
        "collapsed": true,
        "id": "dc984b11-ce8b-4a50-ba0e-47c3371ef9b6"
      },
      "outputs": [],
      "source": [
        "# Visualisieren der Verteilung der Risiko Scores\n",
        "# Wir schauen uns die Riskiowerte an um zu entschieden ob es besonders hohe Werte gibt.\n",
        "# Wenn man exp(Risikowert) berechnet erhält man das Hazard Ratio des Individuums relativ zum Baseline-Risiko\n",
        "risk_scores = optimal_model.predict(X_train)\n",
        "plt.hist(risk_scores, bins=50, edgecolor='k')\n",
        "plt.title(\"Distribution of Risk Scores\")\n",
        "plt.xlabel(\"Risk Score\")\n",
        "plt.ylabel(\"Frequency\")\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "Unsere Risikowerte sind relative hoch. Wir interpretieren daraus, dass es starke Unterschiede zwischen den Individuen gibt die sich auf die Survival time auswirken.\n",
        "Um zu schuane ob es Ausreißer in den Daten gibt schauen wir uns die Individuen mit den höchsten Risikowerten an."
      ],
      "metadata": {
        "id": "yP-5P3r5jiRC"
      },
      "id": "yP-5P3r5jiRC"
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b3cff105-a79e-46aa-bbfc-2b01c9b38697",
      "metadata": {
        "id": "b3cff105-a79e-46aa-bbfc-2b01c9b38697"
      },
      "outputs": [],
      "source": [
        "X_test[rsf_risk_scores_test > 20]"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "47fd6efa-bf3c-4bfa-b20c-e0b4028601d7",
      "metadata": {
        "id": "47fd6efa-bf3c-4bfa-b20c-e0b4028601d7"
      },
      "source": [
        "Es gibt keine Besonderheiten oder extremen Werte bei Individuen mit hohen Risikowerten."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "3586ff75-b9cc-451b-8e1e-07be34f69a4c",
      "metadata": {
        "id": "3586ff75-b9cc-451b-8e1e-07be34f69a4c"
      },
      "outputs": [],
      "source": [
        "from sklearn.inspection import permutation_importance\n",
        "\n",
        "# Bestimmen der Permutation Importances\n",
        "perm_importance = permutation_importance(optimal_model, X_test, y_test, n_repeats=10, random_state=42)\n",
        "\n",
        "# Erstellen einen Dataframes von Feature und Importance\n",
        "feature_importance_df = pd.DataFrame({\n",
        "    \"Feature\": X_test.columns,\n",
        "    \"Importance\": perm_importance.importances_mean\n",
        "})\n",
        "feature_importance_df = feature_importance_df.sort_values(by=\"Importance\", ascending=False)\n",
        "\n",
        "# Erstellen des Permutation Importance Plots\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.barh(feature_importance_df[\"Feature\"], feature_importance_df[\"Importance\"], color=\"skyblue\")\n",
        "plt.xlabel(\"Mean Veränderung des Concordance Indexes\")\n",
        "plt.ylabel(\"Feature\")\n",
        "plt.title(\"Permutation Wichtigkeit für den Random Survival Forest\")\n",
        "plt.gca().invert_yaxis()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "Im folgenden Teil versuchen wir, die vorhergesagte durchschnittliche Überlebenszeit des gesamten Testdatensatzes mit der tatsächlichen Überlebenszeit zu vergleichen.\n",
        "\\\n",
        "Der Random Survival Forest schätzt lediglich eine Hazard-Funktion, die in eine Survival-Kurve umgewandelt werden muss.\n",
        "\\\n",
        "Außerdem verfügen wir nicht über die direkte Überlebenszeit für alle Individuen im Datensatz, da viele noch bei IBM arbeiten. Deshalb müssen wir die durchschnittliche Überlebenszeit mithilfe des Kaplan-Meier-Fitters berechnen."
      ],
      "metadata": {
        "id": "FsA7CBYVm71x"
      },
      "id": "FsA7CBYVm71x"
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7f1e82fb-2c33-4284-9330-dae1084bb391",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "7f1e82fb-2c33-4284-9330-dae1084bb391",
        "outputId": "8331385e-4b3b-4602-881d-81acaa2b5b7b"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Vorhergesagte Mean Survival Time: 29.62\n",
            "Bereinigte Beobachtete Mean Survival Time: 27.17\n"
          ]
        }
      ],
      "source": [
        "from lifelines import KaplanMeierFitter\n",
        "import numpy as np\n",
        "\n",
        "# Vorhersage der Überlebenskurven für jede Person im Test Datensatz\n",
        "predicted_survival_curves = optimal_model.predict_survival_function(X_test)\n",
        "\n",
        "# Berechnung der erwarteten Überlebenszeit für jede Person\n",
        "expected_survival_times = []\n",
        "for survival_curve in predicted_survival_curves:\n",
        "    time_points = survival_curve.x\n",
        "    survival_probs = survival_curve.y\n",
        "    time_diffs = np.diff(np.append(0, time_points))\n",
        "    expected_time = np.sum(survival_probs * time_diffs)\n",
        "    expected_survival_times.append(expected_time)\n",
        "\n",
        "# Berechnung der mean vorhergesagten Überlebenszeit\n",
        "expected_survival_times = np.array(expected_survival_times)\n",
        "predicted_mean_time = expected_survival_times.mean()\n",
        "print(f\"Vorhergesagte Mean Survival Time: {predicted_mean_time:.2f}\")\n",
        "\n",
        "# Kaplan Meier Schätzung (Fitter)\n",
        "# Ist eine statistische Methode zur Schätzung der Überlebenswahrscheinlichtkeit (Eintreffen eines Ereignisses), über die Zeit.\n",
        "# Wir benutzen diese Mehtode da mna nicht dirkt die beobachtete Überlebenszeit berechnen kann, da viele Angestellte noch im Unternehmen sind.\n",
        "#  ->  Liefert eine Treppenfunktion, welche bei jedem Ereigniszeitpunkt abnimmt.\n",
        "#  ->  Berücksichtigt zensierte Daten (Daten bei denen das Ereignis nicht im Beobachtungszeitraum eintritt) und entfernt diese aus der Berechnung.\n",
        "\n",
        "# Anpassen des Kaplan-Meier-Modells an die Test Daten\n",
        "kmf_test = KaplanMeierFitter()\n",
        "kmf_test.fit(y_test_time, event_observed=y_test_event)\n",
        "\n",
        "# Extraktion der ÜKaplan-Meier-bereinigten beobachteten mittleren Überlebenszeit\n",
        "survival_probs = kmf_test.survival_function_.values.flatten()\n",
        "time_points = kmf_test.survival_function_.index.values\n",
        "time_diffs = np.diff(np.append(0, time_points))\n",
        "adjusted_mean_time = np.sum(survival_probs * time_diffs)\n",
        "print(f\"Bereinigte Beobachtete Mean Survival Time: {adjusted_mean_time:.2f}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "Im folgenden Teil versuchen wir, die Survival Analysis als Klassifizierungsproblem umzugestalten. Dabei schauen wir, ob über einen gewissen Zeitraum die Angestellten tatsächlich im Unternehmen geblieben sind. Das Modell mithilfe des Kaplan Meier Fitters sagt gleichzeitig die Überlebenswahrscheinlichkeit für diesen Zeitraum aus. Bei einer Wahrscheinlichkeit von 0.5 und darüber wird also vorhergesagt, dass die Person überlebt. So können wir Metriken wie Accuracy etc. berechnen. Wir nehmen heirfür den ganzen Datensatz, da die Anzahl der Leute die das Unternehmen bereits verlassen, sowieso relativ klein ist, wäre es nicht sinnvoll sich auf den Testdatensatz zu beschränken."
      ],
      "metadata": {
        "id": "tOgLWAfTnNu0"
      },
      "id": "tOgLWAfTnNu0"
    },
    {
      "cell_type": "code",
      "source": [
        "from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score\n",
        "\n",
        "# Spezifische Jahre definieren\n",
        "time_points = [1, 2, 5]  # Zeitpunkte in Jahren\n",
        "results = []\n",
        "\n",
        "predicted_survival_curves_x = optimal_model.predict_survival_function(X)\n",
        "\n",
        "for t in time_points:\n",
        "    # Überlebenswahrscheinlichkeiten für den spezifischen Zeitpunkt berechnen\n",
        "    predicted_probs_at_time = np.array([sf(t) for sf in predicted_survival_curves_x])\n",
        "\n",
        "    # Maske für gültige Fälle\n",
        "    # Jeder der t oder weniger Jahre im Unternehmen war und bereits gegangen ist.\n",
        "    actual_status_at_time = np.where((y[\"time\"] <= t) & (y[\"event\"] == 0), 0, 1)\n",
        "    # Über einer Wahrscheinlichkeit von 0.5 wird als survival und darunter als nicht survival Klassifiziert\n",
        "    actual_predictions = (predicted_probs_at_time >= 0.5).astype(int)\n",
        "\n",
        "    # Berechnen der Scores\n",
        "    accuracy = accuracy_score(actual_status_at_time, actual_predictions)\n",
        "    precision = precision_score(actual_status_at_time, actual_predictions, zero_division=0)\n",
        "    recall = recall_score(actual_status_at_time, actual_predictions, zero_division=0)\n",
        "\n",
        "    results.append({\n",
        "        \"time\": t,\n",
        "        \"Accuracy\": accuracy,\n",
        "        \"Precision\": precision,\n",
        "        \"Recall\": recall,\n",
        "    })\n",
        "\n",
        "# Anziegen der Resultate\n",
        "for res in results:\n",
        "    print(f\"Time {res['time']} year(s): \"\n",
        "          f\"Accuracy={res['Accuracy']:.2f}, \"\n",
        "          f\"Precision={res['Precision']:.2f}, \"\n",
        "          f\"Recall={res['Recall']:.2f}, \")"
      ],
      "metadata": {
        "id": "TYKv8aqXyi6N"
      },
      "id": "TYKv8aqXyi6N",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "id": "f55beb13-92f2-49b1-ae95-e9c8552b1cf7",
      "metadata": {
        "id": "f55beb13-92f2-49b1-ae95-e9c8552b1cf7"
      },
      "source": [
        "Die Accuracy und die Precision des Modells starten mit guten Werten nehmen aber zunehmend ab, das Modell ist somit nur mäßig dafür geeignet Vorhersagen über längere Zeiträume zu treffen. Wobei der Recall relativ hoch bleibt, das Modell erkennt also die Personen die gehen wollen aber bewertet auch viele die nicht gehen wollen als positives, es gibt also viele falsche Positive."
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c5a65b04-fd08-4094-8da8-52ed4faf1966",
      "metadata": {
        "id": "c5a65b04-fd08-4094-8da8-52ed4faf1966"
      },
      "source": [
        "# Verbesserung der Durchschnittsüberlebenszeit"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "In folgendem Teil suchen wir uns eine Person aus dem Trainingsdatensatz heraus. Für diese Person berechnen wir die vorhergesagte durchschnittliche Überlebenswahrscheinlichkeit und versuchen zu ermitteln, mit welchen Veränderungen von Variablen man eine längere durchschnittliche Überlebenswahrscheinlichkeit erzielen kann. Hierbei beschränken wir uns auf Variablen, die der Arbeitgeber verändern kann."
      ],
      "metadata": {
        "id": "GbZk667QoR3W"
      },
      "id": "GbZk667QoR3W"
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d79427a5-32b1-4e3e-aaf6-ff4ba16377fb",
      "metadata": {
        "id": "d79427a5-32b1-4e3e-aaf6-ff4ba16377fb"
      },
      "outputs": [],
      "source": [
        "# Erstellen einer einzigen Observation (Person)\n",
        "person_number = 1\n",
        "person = X_train.iloc[[person_number]]\n",
        "t_condition = y_train['time'][person_number]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6ed135e0-454b-4020-9d0b-6774719b16de",
      "metadata": {
        "id": "6ed135e0-454b-4020-9d0b-6774719b16de",
        "outputId": "24534a43-07b2-4769-ecfd-34ba6e9e840a"
      },
      "outputs": [
        {
          "data": {
            "text/plain": [
              "9.63862308196837"
            ]
          },
          "execution_count": 28,
          "metadata": {},
          "output_type": "execute_result"
        }
      ],
      "source": [
        "  from lifelines import KaplanMeierFitter\n",
        "\n",
        "  # Anpassen des Kaplan-Meier-Modells an die Trainings Daten\n",
        "  kmf_train = KaplanMeierFitter()\n",
        "  kmf_train.fit(y_train_time, event_observed=y_train_event)\n",
        "\n",
        "  # Vorhersage des ursprünglichen Risikoscores und der Hazardratio\n",
        "  original_risk_score = optimal_model.predict(person)\n",
        "  original_hazard_ratio = np.exp(original_risk_score)\n",
        "\n",
        "  # Extrahiere die Basis-Überlebenskurve\n",
        "  baseline_times = kmf_train.survival_function_.index.values  # Zeitpunkte der Basis-Überlebensfunktion\n",
        "  baseline_survival = kmf_train.survival_function_.values.flatten()\n",
        "\n",
        "  # Erstellen einer Funktion umd dei verbeleibende Überlebenszeit zu berechnen -> für jede person die weitere Zeit im unternehmen\n",
        "  def compute_conditional_expected_time(hazard_ratio, baseline_survival, baseline_times, t_condition):\n",
        "\n",
        "      # Finden der Überlebenswahrscheinlichkeit bei t_condition\n",
        "      idx_condition = np.searchsorted(baseline_times, t_condition, side=\"right\") - 1\n",
        "      survival_prob_at_t_condition = baseline_survival[idx_condition]\n",
        "\n",
        "      # Passe die Überlebenswahrscheinlichkeiten der Basisfunktion mithilfe der Hazardratio des Individuums an\n",
        "      adjusted_survival_probs = (baseline_survival / survival_prob_at_t_condition) ** hazard_ratio\n",
        "      adjusted_survival_probs[baseline_times <= t_condition] = 0\n",
        "\n",
        "      # Berechne die bedingte erwartete Überlebenszeit\n",
        "      time_diffs = np.diff(np.append(0, baseline_times))\n",
        "      conditional_expected_time = np.sum(adjusted_survival_probs * time_diffs)\n",
        "      return conditional_expected_time\n",
        "\n",
        "  # Anwenden der Funktion\n",
        "  conditional_expected_survival_time = compute_conditional_expected_time(\n",
        "      original_hazard_ratio, baseline_survival, baseline_times, t_condition\n",
        "  )\n",
        "  conditional_expected_survival_time"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7cd0b206-628f-49b3-bfd9-993e42ae41a7",
      "metadata": {
        "collapsed": true,
        "id": "7cd0b206-628f-49b3-bfd9-993e42ae41a7",
        "outputId": "f4bdcadd-648f-4bbb-eefa-91f3d7cdd5f0"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Veränderung für die längste Überlebenszeit: no_overtime\n"
          ]
        }
      ],
      "source": [
        "# Beförderung: YearsSinceLastPromotion, JobLevel\n",
        "person_higher_joblevel = person.copy()\n",
        "\n",
        "person_higher_joblevel['JobLevel'] = person_higher_joblevel['JobLevel'].astype(int)\n",
        "if (person_higher_joblevel['JobLevel'] != 5).any():\n",
        "    person_higher_joblevel['JobLevel'] += 1\n",
        "    person_higher_joblevel['YearsSinceLastPromotion'] = (0 - df_mean['YearsSinceLastPromotion']) / df_std['YearsSinceLastPromotion']\n",
        "person_higher_joblevel['JobLevel'] = person_higher_joblevel['JobLevel'].astype('category')\n",
        "\n",
        "changed_risk_score = optimal_model.predict(person_higher_joblevel)\n",
        "changed_hazard_ratio = np.exp(changed_risk_score)\n",
        "\n",
        "conditional_expected_survival_time_higher_joblevel = compute_conditional_expected_time(\n",
        "    changed_hazard_ratio, baseline_survival, baseline_times, t_condition\n",
        ")\n",
        "\n",
        "# OverTime\n",
        "person_no_overtime = person.copy()\n",
        "person_no_overtime['OverTime'] = 0\n",
        "person_no_overtime['OverTime'] = person_no_overtime['OverTime'].astype('category')\n",
        "\n",
        "changed_risk_score = optimal_model.predict(person_no_overtime)\n",
        "changed_hazard_ratio = np.exp(changed_risk_score)\n",
        "\n",
        "conditional_expected_survival_time_no_overtime = compute_conditional_expected_time(\n",
        "    changed_hazard_ratio, baseline_survival, baseline_times, t_condition\n",
        ")\n",
        "\n",
        "# Environment Satisfaction\n",
        "person_higher_environment_satisfaction = person.copy()\n",
        "\n",
        "person_higher_environment_satisfaction['EnvironmentSatisfaction'] = person_higher_environment_satisfaction['EnvironmentSatisfaction'].astype(int)\n",
        "if (person_higher_environment_satisfaction['EnvironmentSatisfaction'] != 4).any():\n",
        "    person_higher_environment_satisfaction['EnvironmentSatisfaction'] += 1\n",
        "person_higher_environment_satisfaction['EnvironmentSatisfaction'] = person_higher_environment_satisfaction['EnvironmentSatisfaction'].astype('category')\n",
        "\n",
        "changed_risk_score = optimal_model.predict(person_higher_environment_satisfaction)\n",
        "changed_hazard_ratio = np.exp(changed_risk_score)\n",
        "\n",
        "conditional_expected_survival_time_higher_environment_satsfaction = compute_conditional_expected_time(\n",
        "    changed_hazard_ratio, baseline_survival, baseline_times, t_condition\n",
        ")\n",
        "\n",
        "# StockOptionLevel\n",
        "person_higher_stockoption = person.copy()\n",
        "\n",
        "person_higher_stockoption['StockOptionLevel'] = person_higher_stockoption['StockOptionLevel'].astype(int)\n",
        "if (person_higher_stockoption['StockOptionLevel'] != 3).any():\n",
        "    person_higher_stockoption['StockOptionLevel'] += 1\n",
        "person_higher_stockoption['StockOptionLevel'] = person_higher_stockoption['StockOptionLevel'].astype('category')\n",
        "\n",
        "changed_risk_score = optimal_model.predict(person_higher_stockoption)\n",
        "changed_hazard_ratio = np.exp(changed_risk_score)\n",
        "\n",
        "conditional_expected_survival_time_higher_stockoption = compute_conditional_expected_time(\n",
        "    changed_hazard_ratio, baseline_survival, baseline_times, t_condition\n",
        ")\n",
        "\n",
        "\n",
        "# JobSatisfaction\n",
        "person_higher_jobsatisfaction = person.copy()\n",
        "\n",
        "person_higher_jobsatisfaction['JobSatisfaction'] = person_higher_jobsatisfaction['JobSatisfaction'].astype(int)\n",
        "if (person_higher_jobsatisfaction['JobSatisfaction'] != 4).any():\n",
        "    person_higher_jobsatisfaction['JobSatisfaction'] += 1\n",
        "person_higher_jobsatisfaction['JobSatisfaction'] = person_higher_jobsatisfaction['JobSatisfaction'].astype('category')\n",
        "\n",
        "changed_risk_score = optimal_model.predict(person_higher_jobsatisfaction)\n",
        "changed_hazard_ratio = np.exp(changed_risk_score)\n",
        "\n",
        "conditional_expected_survival_time_jobsatisfaction = compute_conditional_expected_time(\n",
        "    changed_hazard_ratio, baseline_survival, baseline_times, t_condition\n",
        ")\n",
        "conditional_expected_survival_time_jobsatisfaction\n",
        "\n",
        "\n",
        "def get_max_variable_name_from_values(**kwargs):\n",
        "    max_variable = max(kwargs, key=kwargs.get)  # Get the key with the maximum value\n",
        "    return max_variable\n",
        "# Finden der längsten \"Überlebenszeit\"\n",
        "max_variable = get_max_variable_name_from_values(\n",
        "    no_overtime=conditional_expected_survival_time_no_overtime,\n",
        "    higher_jobsatisfaction=conditional_expected_survival_time_jobsatisfaction,\n",
        "    promotion=conditional_expected_survival_time_higher_joblevel,\n",
        "    higher_environment_satisfaction=conditional_expected_survival_time_higher_environment_satsfaction,\n",
        "    higher_stockoption_level=conditional_expected_survival_time_higher_stockoption\n",
        ")\n",
        "\n",
        "print(f\"Veränderung für die längste Überlebenszeit: {max_variable}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "Leider trifft das Modell bei den meisten Personen die gleiche Aussage, und zwar, dass Overtime verringert werden soll. Wir haben dieses Tool also nicht mit auf die Website übernommen. Auf der Website kann man selbst die Variablen jeder Person anpassen und beobachten, wie sich dies auf die durchschnittliche Überlebenszeit auswirkt."
      ],
      "metadata": {
        "id": "JiUK0rg9pYpO"
      },
      "id": "JiUK0rg9pYpO"
    },
    {
      "cell_type": "markdown",
      "id": "33259603-9c84-447f-9ef2-7e63c5f6fec7",
      "metadata": {
        "id": "33259603-9c84-447f-9ef2-7e63c5f6fec7"
      },
      "source": [
        "# Visualisierung der Survival Curve"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f92a6ff4-74ca-4af6-864a-6a18114098de",
      "metadata": {
        "collapsed": true,
        "id": "f92a6ff4-74ca-4af6-864a-6a18114098de",
        "outputId": "878ac841-12bd-4440-e061-51ba9961a9c0"
      },
      "outputs": [
        {
          "data": {
            "image/png": "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kNq3b6+dO3c69JHd72Nn3oecjvN9+/bZz/gFBwcrOjpaycnJDutevnxZQ4YMUUhIiAIDA/XQQw/pyJEj+b6OKzIyUh9//LFSU1M1efJke3tucrJmzRr72ejo6Gj7+56Znx9//FGPPfaYypcvLx8fH0VERGjYsGG6fPmyQww3+0xnutnvoD59+mjGjBmSHIf6Au7CmSvgFoqMjNSGDRv066+/6u677za178cee0xVqlTRa6+9JsMw9OCDD2rEiBGaP3++/QtQpvnz56tdu3YqUaJEln6sVqs6d+6sRYsW6f3333f4S/fixYuVkpJiH0aSlJSkDz/8UN27d1e/fv104cIFzZo1S1FRUdq8ebPTw0Uyv7D27NnTyb3PnQkTJsjb21vDhw9XSkqKqlevrkqVKmn+/Pnq3bu3w7Lx8fEqUaKEoqKiJEmJiYlq3LixvcgJDQ3V0qVL1bdvXyUlJWno0KHZbjM0NFSffvqpXn31VV28eFETJ06UJN15550yDEMPPfSQVq9erb59+6p27dpavny5nn/+eR05ciTLEMJVq1Zp/vz5iomJUUhISI6TkEybNk2DBw9WQECAXnrpJUlZh0YNHjxYJUqUUFxcnP78809NmzZNMTExio+Pty/z6aefqnfv3oqKitLrr7+u5ORkvffee2rWrJl++umnXE2CcuHCBZ06dcqhrWTJkjc8a3D9sSxJXbp00W+//abBgwerQoUKOnHihBISEnT48GFVqFAhV/ucG2fPntXZs2ftw81+++033XPPPSpbtqxGjhypYsWKaf78+erUqZMWLlyozp07O6w/cOBAhYaGauzYsbp06ZIkqX///vryyy8VExOj6tWr6/Tp01q3bp12796tunXrSrpanEVHR6tBgwaaOHGiEhMT9fbbb+u///2vfvrpJ4c/yKSnpysqKkqNGjXSm2++qe+//15TpkxR5cqVNWDAAKf3WZImTZokDw8PDR8+XOfPn9fkyZP1xBNPaNOmTTmu88gjj+iPP/7Q559/rrfeekshISGSrh7zmdatW6dFixZp4MCBCgwM1DvvvKMuXbro8OHDuu222yTl/bPljOs/+97e3tq1a5cWL16sxx57TBUrVlRiYqLef/99tWjRQrt27VKZMmVu2Gd+34fHH39cFStW1MSJE7V9+3Z9+OGHKlWqlMPZ+T59+mj+/Pnq2bOnGjdurLVr1+qBBx7Idz4kqUmTJqpcubISEhLsbQcOHLhpTu688069/PLLGjt2rJ555hk1b95cktS0aVNJV/9IkJycrAEDBui2227T5s2bNX36dP39999asGCBfVs3+0xLufsd9K9//UtHjx5VQkKCPv30U1NyA+SLAeCWWbFiheHp6Wl4enoaTZo0MUaMGGEsX77cSE1NdVju4MGDhiTjo48+ytKHJCMuLs7+PC4uzpBkdO/ePcuyTZo0MerVq+fQtnnzZkOS8cknn9jbevfubURGRtqfL1++3JBk/Oc//3FYt0OHDkalSpXsz9PS0oyUlBSHZc6ePWuEhYUZTz311A3jzk6dOnWM4ODgGy5zrcjISKN3795Z2lu0aGG0aNHC/nz16tWGJKNSpUpGcnKyw7KjRo0yrFarcebMGXtbSkqKUbx4cYd96Nu3r1G6dGnj1KlTDut369bNCA4OztJvdjHdddddDm2LFy82JBmvvPKKQ/ujjz5qWCwWY9++ffY2SYaHh4fx22+/3XA7me666y6HHGT66KOPDElGmzZtjIyMDHv7sGHDDE9PT+PcuXOGYRjGhQsXjOLFixv9+vVzWP/48eNGcHBwlvbrZeY8u8fBgwft+5SbY/ns2bOGJOONN97I0z7nRJLRt29f4+TJk8aJEyeMTZs2Ga1btzYkGVOmTDEMwzBat25t1KhRw7hy5Yp9vYyMDKNp06ZGlSpV7G2ZeW3WrJmRlpbmsJ3g4GBj0KBBOcaRmppqlCpVyrj77ruNy5cv29u//fZbQ5IxduxYe1vv3r0NScbLL7/s0EedOnWyfNazk9Nn484773T4LL/99tuGJOOXX365YX9vvPGGw3t6LUmGt7e3w3G8c+dOQ5Ixffp0e1t+P1uZTp48meWYutFn/8qVK0Z6erpD28GDBw0fHx+H/Gb3+9iZ9yGn4/z635GdO3c2brvtNvvzbdu2GZKMoUOHOizXp0+fXP0+zYz7Rp+bhx9+2JBknD9/3jCM3Odky5YtOf4fld37NXHiRMNisRiHDh0yDCN3n2lnfgcNGjTI4CstCgqGBQK3UNu2bbVhwwY99NBD2rlzpyZPnqyoqCiVLVs2yzAjZ/Xv3z9LW9euXbVt2zbt37/f3hYfHy8fHx89/PDDOfbVqlUrhYSEOJzFOHv2rBISEtS1a1d7m6enp/3MVkZGhs6cOaO0tDTVr18/y5Cn3EhKSlJgYKDT6+VW79695efn59DWtWtX2Ww2LVq0yN62YsUKnTt3zr6vhmFo4cKF6tixowzD0KlTp+yPqKgonT9/Pk/7+91338nT01NDhgxxaH/uuedkGIaWLl3q0N6iRQtVr17d6e1k55lnnnEYOtO8eXOlp6fbh5EmJCTo3Llz6t69u8P+enp6qlGjRrke+jl27FglJCQ4PMLDw2+4zvXHsp+fn7y9vbVmzRr7UFazzJo1S6GhoSpVqpQaNWqk//73v4qNjdXQoUN15swZrVq1So8//rj9DNypU6d0+vRpRUVFae/evVmG7fXr10+enp4ObcWLF9emTZtynOly69atOnHihAYOHOhwfc4DDzygatWqacmSJVnWuT5HzZs314EDB/KaBkVHRzucpc48G5GfPiWpTZs2qly5sv15zZo1FRQUZO/XVZ+t62X32ffx8bGfQU1PT9fp06cVEBCgqlWr5nqb+Xkfslv39OnTSkpKkiT78MmBAwc6LGfmxEcBAQGSrp5hlszJybV5vnTpkk6dOqWmTZvKMAz99NNP9mVu9pk263cQcKsxLBC4xRo0aKBFixYpNTVVO3fu1FdffaW33npLjz76qHbs2JHnL88VK1bM0vbYY48pNjZW8fHxevHFF2UYhhYsWKD27dsrKCgox768vLzUpUsXzZs3TykpKfLx8dGiRYtks9kciitJmjNnjqZMmaLff/9dNpvthvHczLVfulwhu5hq1aqlatWqKT4+Xn379pV0tQANCQlRq1atJEknT57UuXPn9H//93/6v//7v2z7zsuEJIcOHVKZMmWyFJR33nmn/fWbxZ9X5cuXd3ieOUQ084vO3r17Jcmeg+vd6Pi5Vo0aNdSmTRunYrt+P318fPT666/rueeeU1hYmBo3bqwHH3xQvXr1ummhdjMPP/ywYmJiZLFYFBgYqLvuuss+CcW+fftkGIbGjBmjMWPGZLv+iRMnVLZs2Rxjl6TJkyerd+/eioiIUL169dShQwf16tVLlSpVkvS/97lq1apZ1q1WrZrWrVvn0Obr6+sw9E66+v7lp/C82fFgVr+ZfWf266rP1vWye18yMjL09ttv691339XBgwcdrpXKHLJ4I/l9H26U86CgIB06dEgeHh5ZYr92hsT8unjxoiTZfwflNyeSdPjwYY0dO1bffPNNllycP39eUu4+02b9DgJuNYorwE28vb3VoEEDNWjQQHfccYeio6O1YMECxcXF5Xgx7o0uWL/+r7KSVKZMGTVv3lzz58/Xiy++qI0bN+rw4cO5mnGvW7duev/997V06VJ16tRJ8+fPV7Vq1Rxmlfrss8/Up08fderUSc8//7xKlSolT09PTZw40eFsWW5Vq1ZNP/30k/766y9FRETcdPkb5en6swdS9jmSrp69evXVV3Xq1CkFBgbqm2++Uffu3e3TJ2dOU//kk09muTYr07WzlrlKTvHnRXb5kWS/xilznz/99NNsCxhXTi2d3X4OHTpUHTt21OLFi7V8+XKNGTNGEydO1KpVq1SnTp08b6tcuXI5Fn+ZORg+fLj92rvrXf9FN7vYH3/8cTVv3lxfffWVVqxYoTfeeEOvv/66Fi1alKcZCXN67/LjZseDq/q9VZ+t7N6X1157TWPGjNFTTz2lCRMm2K8FHDp0aK5uTZHf98FVOXfGr7/+qlKlStkLlfzmJD09XW3bttWZM2f0wgsvqFq1aipWrJiOHDmiPn36OPRxs8+0O38HAfnBkQkUAPXr15ckHTt2TNL//oJ5/Y05s5v572a6du2qgQMHas+ePYqPj5e/v786dux40/XuvfdelS5dWvHx8WrWrJlWrVplnygg05dffqlKlSpp0aJFDoVOXFyc03FKUseOHfX555/rs88+06hRo266fIkSJbK9eemhQ4fsZwVyo2vXrho/frwWLlyosLAwJSUlOdz7JTQ0VIGBgUpPT3f6LMyNREZG6vvvv9eFCxcczl79/vvv9tfzKr+zZWUO5SpVqpSp+5wflStX1nPPPafnnntOe/fuVe3atTVlyhR99tlnkvK/z9fLPIasVmu+c1C6dGkNHDhQAwcO1IkTJ1S3bl29+uqrat++vf193rNnT5a/0u/Zsydfx4Gr5Tfnrvps5caXX36p++67T7NmzXJoP3funH1yDneKjIxURkaGDh48qCpVqtjbbzaLY25t2LBB+/fvd5imPbc5yel9/+WXX/THH39ozpw56tWrl7392kkzrnWjz7Qzv4OYHRAFCddcAbfQ6tWrs/2r5HfffSfpf8OCgoKCFBISoh9++MFhuXfffdfpbXbp0kWenp76/PPPtWDBAj344IO5uveOh4eHHn30Uf3nP//Rp59+qrS0tCxDAjP/8nrtPm3atEkbNmxwOk5JevTRR1WjRg29+uqr2fZx4cIFhwKvcuXK2rhxo1JTU+1t3377rf766y+ntnvnnXeqRo0aio+PV3x8vEqXLq17773X/rqnp6e6dOmihQsX6tdff82yfnZTmOdGhw4dlJ6ern//+98O7W+99ZYsFku+7rNUrFixbAvP3IqKilJQUJBee+01h+GemfK6z3mRnJysK1euOLRVrlxZgYGBSklJsbfld5+vV6pUKbVs2VLvv/++/Q8f18pNDtLT0+1Doa7tt0yZMvbY69evr1KlSmnmzJkO+7N06VLt3r3btNnhXCHzd0le8+6qz1Zut3397+MFCxZkuY7OXTLPll7/e3/69On57vvQoUPq06ePvL29HWaTzW1Ocnrfs/s/wTAMvf322w7L5eYz7czvoPweh4CZOHMF3EKDBw9WcnKyOnfurGrVqik1NVXr169XfHy8KlSo4HBvqaefflqTJk3S008/rfr16+uHH37QH3/84fQ2S5Uqpfvuu09Tp07VhQsXshRIN9K1a1dNnz5dcXFxqlGjhv1aoEwPPvigFi1apM6dO+uBBx7QwYMHNXPmTFWvXt0+lt8ZVqtVixYtUps2bXTvvffq8ccf1z333COr1arffvtN8+bNU4kSJez3unr66af15Zdf6v7779fjjz+u/fv3O/zF0xldu3bV2LFj5evrq759+2aZKnzSpElavXq1GjVqpH79+ql69eo6c+aMtm/fru+//15nzpxxepsdO3bUfffdp5deekl//vmnatWqpRUrVujrr7/W0KFD87QfmerVq6f33ntPr7zyim6//XaVKlUqx2sXshMUFKT33ntPPXv2VN26ddWtWzeFhobq8OHDWrJkie65554sRaGr/PHHH2rdurUef/xxVa9eXV5eXvrqq6+UmJjocIYxv/ucnRkzZqhZs2aqUaOG+vXrp0qVKikxMVEbNmzQ33//neWeSNe7cOGCypUrp0cffVS1atVSQECAvv/+e23ZskVTpkyRdPW4f/311xUdHa0WLVqoe/fu9qnYK1SooGHDhuVrH1ypXr16kqSXXnpJ3bp1k9VqVceOHZ26ebIrPlu58eCDD+rll19WdHS0mjZtql9++UVz58516qy3K9WrV09dunTRtGnTdPr0aftU7Jn/D+T2bM327dv12WefKSMjQ+fOndOWLVu0cOFCWSwWffrppw7DLnObk8qV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OnSoQkJCFBUVpR49eqhr164O69lsNoWEhOiTTz6RdHUq94kTJ6pixYry8/NTrVq19OWXX+Z6H/LKrfe5+uGHH/TGG29o27ZtOnbsmL766qssCb7emjVrFBsbq99++00REREaPXq0+vTp47DMjBkz9MYbb+j48eOqVauWpk+froYNG7puRwAAAHDLXbalq/rY5W7Z9q/j2uZquYCAAAUEBGjx4sVq3LixfHx88rXdkSNH6s0331SlSpVUokQJffDBB5o7d64mTJhgX2bu3Lnq0aNHlnWDgoL04IMPat68eWrfvr3D8p06dZK/v78kKTAwUB9//LHKlCmjX375Rf369VNgYKBGjBiRqxjnzp2rgIAADRw4MNvXixcv7sQeS3PmzNGAAQPswyj37dunxx57zH6TYUlavny5kpOT1blzZ0nSxIkT9dlnn2nmzJmqUqWKfvjhBz355JMKDQ1VixYtnNq+M9x65urSpUuqVauWZsyYkavlDx48qAceeED33XefduzYoaFDh+rpp5/W8uX/+1DFx8crNjZWcXFx2r59u2rVqqWoqCidOHHCVbsBAAAAZMvLy0sff/yx5syZo+LFi+uee+7Riy++qJ9//jlP/b388stq27atKleurJIlS+qJJ57Q559/bn/9jz/+0LZt2/TEE09ku/4TTzyhxYsX289SJSUlacmSJQ7Ljx492n62qWPHjho+fLjmz5+f6xj37t2rSpUqyWq15mkfr1elShVNnjxZVatWVdWqVRUVFaVixYrpq6++si8zb948PfTQQwoMDFRKSopee+01zZ49W1FRUapUqZL69OmjJ598Uu+//74pMeXErWeu2rdv71A138zMmTNVsWJFTZkyRZJ05513at26dXrrrbcUFRUlSZo6dar69eun6Oho+zpLlizR7NmzNXLkSPN3woUyT3WnpEvJqWmyGvkbK+tn9eSmewAAoMjws3pq18tRbtm2j6dFF67kbtkuXbrogQce0I8//qiNGzdq6dKlmjx5sj788MMsI7Bupn79+g7Pu3XrpuHDh2vjxo1q3Lix5s6dq7p166patWrZrt+hQwdZrVZ988036tatmxYuXKigoCC1adPGvkx8fLzeeecd7d+/XxcvXlRaWpqCgoJyHWNuh0zmVr169Ryee3l56fHHH9fcuXPVs2dPXbp0SV9//bW++OILSVfPbCUnJ6ttW8ezi6mpqapTp46psV3PrcWVszZs2ODwxktSVFSUhg4dKulqwrZt26ZRo0bZX/fw8FCbNm20YcOGHPtNSUlRSkqK/XlSUpKkq2M3nRlfarbk1DTVmrBKkpdGbF6V7/7qlS+uz59uQIF1jcz3153vc1FGfl2L/LoeOXYt8utaRTG/NptNhmEoIyNDGRkZkiRfL/cMxMosIDLjuRlvb2+1bt1arVu31ksvvaR+/fopLi5OvXr1si+Tnp5u7yvzu2nmvma2+/n5OWyvVKlSuu+++zR37lw1bNhQ8+bNU//+/e3LXPtvRkaGvLy81KVLF82dO9deoDz++OPy8PBQRkaGNmzYoCeeeELjxo1Tu3btFBwcrPj4eE2dOtXeV+a+57TfVapU0bp165SSknLDs1cWi8Vh36T/TVhxbX79/f2zbKt79+667777dPz4cSUkJMjPz0/t2rVTRkaG/bv8f/7zH5UtW9ZhPR8fn2zjzsjIkGEYstls8vT0dHjNmc9QoSqujh8/rrCwMIe2sLAwJSUl6fLlyzp79qzS09OzXeb6C/2uNXHiRI0fPz5L+4oVK+xjT90hJV0y8y3advicFn+7VD6eN1/2nyYhIcHdIRRp5Ne1yK/rkWPXIr+uVZTy6+XlpfDwcF28eLHAzBp34cKFPK1XqVIlXbx4UUlJSfbrsPbv32+fiGL9+vWSpOTkZCUlJdmH8V24cEEeHo4F5SOPPKK4uDh17NhRBw4cUIcOHewFRnbrderUSZ07d9amTZu0evVqjRw50r786tWrFRERoZiYGHv/+/btk2EY9mVSUlKUnp5uf369hx56SNOnT9dbb72l/v37Z3n9/PnzCg4OVlBQkH7++WeHfrZt2yar1WrPa3p6ulJTU7Ns6+6771bZsmX1ySefKCEhQQ899JAuX76sy5cvq1y5cvLx8dGePXuyPVOVXdypqam6fPmyfvjhhyyzMGbmMDcKVXHlKqNGjVJsbKz9eVJSkiIiItSuXTunToGazTAMtWqVolWrVqlVq1ayWvP2dl1OTVfj19dKkqKi2snfm7c9k81mU0JCgtq2bWvauGD8D/l1LfLreuTYtcivaxXF/F65ckV//fWXAgIC5Ovr69ZYDMPQhQsXFBgYeMNRQadPn1bXrl3Vp08f1axZU4GBgdq6daumT5+uhx9+WEFBQQoKClLjxo3173//W3fddZdOnDihSZMmSZL8/f0VFBTkMNnE9d9Pe/Tooeeee04jRozQfffdp6pVq9pfy269+++/X+Hh4RowYIAqVqyoVq1a2Ze/++679ffff+u7775TgwYN9N1332nJkiWyWCz29X18fOTp6Znj9+RWrVrp+eef1+jRo3X69Gl16tRJZcqU0b59+/T++++rWbNmGjJkiO6//35Nnz5dixcvVpMmTTR37lz9/vvvqlOnjgIDA3XhwgV5enrK29s722098cQT9untV65caV8mKChIzz33nEaPHi0fHx81a9ZM58+f1/r16xUYGGifrfBaV65ckZ+fn+69994sx1ZORWR2CtW37PDwcCUmJjq0JSYmKigoSH5+fvL09JSnp2e2y4SHh+fYr4+PT7Yzt1itVrf/Mgq2WOTjKQUX881zLFZr2jU/W/NcpBVlBeG9LsrIr2uRX9cjx65Ffl2rKOU3PT1dFotFHh4eWc7e3GqZQ8sy48lJUFCQGjVqpLffflv79++XzWZTRESE+vXrpxdffNG+7uzZs9W3b181aNBAVatW1eTJk9WuXTv7vmYul92+BwcHq2PHjpo/f75mz57t8HpO63Xv3l2TJ0/W2LFjHdo7deqkYcOGaciQIUpJSdEDDzygMWPGaNy4cfblMovJG+335MmTVb9+fc2YMUPvv/++MjIyVLlyZT366KPq06ePPDw81L59e40ZM0YjR47UlStX9NRTT6lXr1765Zdf7NuwWCw55vjJJ5/Ua6+9psjISDVv3tyhyH3llVdUqlQpvf766/rXv/6l4sWLq27dug45v5aHh4csFku2nxdnPj8Ww+wrzvLIYrHcdCr2F154Qd99951++eUXe1uPHj105swZLVu2TJLUqFEjNWzYUNOnT5d09cAvX768YmJicj2hRVJSkoKDg3X+/Hm3nrmSrv7V6bvvvrNffJgXyalp9mlKd70cxZmra5iRX+SM/LoW+XU9cuxa5Ne1imJ+r1y5ooMHD6pixYpuP3OVeW1PUFCQ2wu9ouhW5/dGx5YztYFbj4SLFy9qx44d9humHTx4UDt27NDhw4clXR2ud+1Ffv3799eBAwc0YsQI/f7773r33Xc1f/58DRs2zL5MbGysPvjgA82ZM0e7d+/WgAEDdOnSJfvsgQAAAADgCm49hbF161bdd9999ueZ1z317t1bH3/8sY4dO2Yv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RbWTv7f7vwIUpfwWROTXtcivaxWk/GaOassNt/1mDQkJkaenpxITEx3aExMTFR4enu06oaGhWrx4sa5cuaLTp0+rTJkyGjlypCpVqpTnPiXJx8dHPj4+WdqtVqvb38xMBSmWooj8uhb5dS3y63pFIcdWw/K/n61WWa3uL64yFYX8FmTk17XIr2sVhPw6s323TWjh7e2tevXqaeXKlfa2jIwMrVy5Uk2aNLnhur6+vipbtqzS0tK0cOFCPfzww/nuEwAAAADyw61/toqNjVXv3r1Vv359NWzYUNOmTdOlS5cUHR0tSerVq5fKli2riRMnSpI2bdqkI0eOqHbt2jpy5IjGjRunjIwMjRgxItd9AgAAAIAruLW46tq1q06ePKmxY8fq+PHjql27tpYtW2afkOLw4cPy8PjfybUrV65o9OjROnDggAICAtShQwd9+umnKl68eK77BAAAAABXcPuA65iYGMXExGT72po1axyet2jRQrt27cpXnwAAAADgCm69iTAAAAAAFBUUVwAAAABgAoorAAAAADABxRUAAAAAmIDiCgAAAABMQHEFAAAAACaguAIAAAAAE1BcAQAAAIAJKK4AAAAAwAQUVwAAAABgAoorAAAAADABxRUAAAAAmIDiCgAAAABMQHEFAAAAACZwurhq0aKFPvnkE12+fNkV8QAAAABAoeR0cVWnTh0NHz5c4eHh6tevnzZu3OiKuAAAAACgUHG6uJo2bZqOHj2qjz76SCdOnNC9996r6tWr680331RiYqIrYgQAAACAAi9P11x5eXnpkUce0ddff62///5bPXr00JgxYxQREaFOnTpp1apVZscJAABMkpyaruTUtHw9DMNw924AQIHjlZ+VN2/erI8++khffPGFSpUqpT59+ujIkSN68MEHNXDgQL355ptmxQkAAExS/5Xv899HZAkt6N9EFovFhIgAoGhw+szViRMnNGXKFN19991q3ry5Tp48qc8//1x//vmnxo8frw8//FArVqzQzJkzXREvAADIAz+rp+pHljCtv62HzuqyLd20/gCgKHD6zFW5cuVUuXJlPfXUU+rTp49CQ0OzLFOzZk01aNDAlAABAED+WSwWLejfJN8FUXJquilnvgCgKHK6uFq5cqWaN29+w2WCgoK0evXqPAcFAADMZ7FY5O+drysCAAA34PSwwLi4OJ07dy5Le1JS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1ePVarUaCxYssC+ze/duQ5KxYcMGd4VZaF2fX8MwjBYtWhjPPvus+4IqYkqUKGF8+OGHHLsukplfw+DYNcuFCxeMKlWqGAkJCQ45LYzHMGeuCqjU1FRt27ZNbdq0sbd5eHioTZs22rBhgxsjKzr27t2rMmXKqFKlSnriiSd0+PBhd4dUJB08eFDHjx93OJaDg4PVqFEjjmUTrVmzRqVKlVLVqlU1YMAAnT592t0hFVrnz5+XJJUsWVKStG3bNtlsNodjuFq1aipfvjzHcB5cn99Mc+fOVUhIiO6++26NGjVKycnJ7givUEtPT9cXX3yhS5cuqUmTJhy7Jrs+v5k4dvNv0KBBeuCBBxyOValw/v71cncAyN6pU6eUnp6usLAwh/awsDD9/vvvboqq6GjUqJE+/vhjVa1aVceOHdP48ePVvHlz/frrrwoMDHR3eEXK8ePHJSnbYznzNeTP/fffr0ceeUQVK1bU/v379eKLL6p9+/basGGDPD093R1eoZKRkaGhQ4fqnnvu0d133y3p6jHs7e2t4sWLOyzLMey87PIrST169FBkZKTKlCmjn3/+WS+88IL27NmjRYsWuTHawuOXX35RkyZNdOXKFQUEBOirr75S9erVtWPHDo5dE+SUX4lj1wxffPGFtm/fri1btmR5rTD+/qW4wj9S+/bt7T/XrFlTjRo1UmRkpObPn6++ffu6MTLAed26dbP/XKNGDdWsWVOVK1fWmjVr1Lp1azdGVvgMGjRIv/76K9dgukhO+X3mmWfsP9eoUUOlS5dW69attX//flWuXPlWh1noVK1aVTt27ND58+f15Zdfqnfv3lq7dq27wyoycspv9erVOXbz6a+//tKzzz6rhIQE+fr6ujscUzAssIAKCQmRp6dnltlQEhMTFR4e7qaoiq7ixYvrjjvu0L59+9wdSpGTebxyLN86lSpVUkhICMezk2JiYvTtt99q9erVKleunL09PDxcqampOnfunMPyHMPOySm/2WnUqJEkcQznkre3t26//XbVq1dPEydOVK1atfT2229z7Jokp/xmh2PXOdu2bdOJEydUt25deXl5ycvLS2vXrtU777wjLy8vhYWFFbpjmOKqgPL29la9evW0cuVKe1tGRoZWrlzpMM4X5rh48aL279+v0qVLuzuUIqdixYoKDw93OJaTkpK0adMmjmUX+fvvv3X6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",
            "text/plain": [
              "<Figure size 1000x600 with 1 Axes>"
            ]
          },
          "metadata": {},
          "output_type": "display_data"
        }
      ],
      "source": [
        "# Get the survival function for the first person in the training dataset\n",
        "survival_function = optimal_model.predict_survival_function(person)\n",
        "\n",
        "# Plot the survival curve\n",
        "plt.figure(figsize=(10, 6))\n",
        "for fn in survival_function:\n",
        "    plt.step(fn.x, fn.y, where=\"post\", label=\"Survival Curve\")\n",
        "\n",
        "plt.title(\"Survival Curve for the First Person in the Training Dataset\")\n",
        "plt.xlabel(\"Time (Years at Company)\")\n",
        "plt.ylabel(\"Survival Probability\")\n",
        "plt.grid(True)\n",
        "plt.legend()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "# Verbesserung des PerformanceRatings\n",
        "\n",
        "Im folgenden Modell versuchen wir herauszufinden, wie man neben der Zeit im Unternehmen auch die Performance der Angestellten erhöhen kann."
      ],
      "metadata": {
        "id": "JDuMM8tJV-Wk"
      },
      "id": "JDuMM8tJV-Wk"
    },
    {
      "cell_type": "code",
      "source": [
        "#Explorative Analyse der Variablen\n",
        "\n",
        "# Korrelation von numerischen Variablen\n",
        "numerical_features = df.select_dtypes(include=['int64', 'float64'])\n",
        "correlation_matrix = numerical_features.corr()\n",
        "\n",
        "# Visualisierung\n",
        "plt.figure(figsize=(10, 8))\n",
        "sns.heatmap(correlation_matrix, annot=True, fmt=\".2f\", cmap=\"coolwarm\")\n",
        "plt.title(\"Korrelationsmatrix der numerischen Features\")\n",
        "plt.show()\n",
        "\n",
        "\n",
        "# Beispiel: Verteilung von Attrition nach PerformanceRating\n",
        "sns.countplot(data=df, x='PerformanceRating', hue='Attrition')\n",
        "plt.title(\"Verteilung von Attrition nach PerfromanceRating\")\n",
        "plt.xticks(rotation=45)\n",
        "plt.show()\n"
      ],
      "metadata": {
        "id": "xJJJNdPS8ano"
      },
      "id": "xJJJNdPS8ano",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# Regressionsmodell für performanceRating\n",
        "\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\n",
        "\n",
        "# Zielvariablen\n",
        "X = df.drop(['PerformanceRating'], axis =1)\n",
        "y_performance = df['PerformanceRating']\n",
        "\n",
        "# Daten aufteilen (z. B. für PerformanceRating)\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y_performance, test_size=0.3, random_state=42)\n",
        "\n",
        "# Modell für Performance trainieren (z. B. Random Forest Regressor)\n",
        "regressor = RandomForestRegressor(random_state=42)\n",
        "regressor.fit(X_train, y_train)\n",
        "\n",
        "# Feature-Importanz\n",
        "importances = regressor.feature_importances_\n",
        "features = X.columns\n",
        "\n",
        "# Visualisierung\n",
        "sns.barplot(x=importances, y=features)\n",
        "plt.title(\"Feature-Importanz für PerformanceRating\")\n",
        "plt.show()"
      ],
      "metadata": {
        "id": "Yr3aVtHKV9He"
      },
      "id": "Yr3aVtHKV9He",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "#Das Modell soll zeigen wie performanceRating durch percentsalaryhike vorhergesagt wird.\n",
        "\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.ensemble import RandomForestRegressor\n",
        "import pandas as pd\n",
        "from sklearn.metrics import mean_squared_error, r2_score\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Angenommen, df ist dein DataFrame und PerformanceRating ist die Zielvariable\n",
        "X = df[['PercentSalaryHike']]\n",
        "y = df['PerformanceRating']\n",
        "\n",
        "# Aufteilen der Daten in Trainings- und Testdaten\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n",
        "\n",
        "# Modell trainieren\n",
        "model = RandomForestRegressor(random_state=42)\n",
        "model.fit(X_train, y_train)\n",
        "\n",
        "# Vorhersage\n",
        "predictions = model.predict(X_test)\n",
        "\n",
        "# Modellbewertung\n",
        "mse = mean_squared_error(y_test, predictions)  # Mean Squared Error\n",
        "r2 = r2_score(y_test, predictions)  # R²-Wert\n",
        "\n",
        "# Ausgabe der Modellbewertung\n",
        "print(f\"Mean Squared Error: {mse}\")\n",
        "print(f\"R²-Wert: {r2}\")\n",
        "\n",
        "# Visualisierung der Vorhersagen vs. tatsächliche Werte\n",
        "plt.scatter(X_test, y_test, color='blue', label='Tatsächliche Werte')\n",
        "plt.scatter(X_test, predictions, color='red', label='Vorhergesagte Werte')\n",
        "plt.xlabel('Percent Salary Hike')\n",
        "plt.ylabel('Performance Rating')\n",
        "plt.title('Vorhersage von Performance Rating durch Percent Salary Hike')\n",
        "plt.legend()\n",
        "plt.show()\n",
        "\n",
        "# Feature-Importanz anzeigen\n",
        "importances = model.feature_importances_\n",
        "print(\"Feature Importances: \", importances)\n",
        "\n",
        "\n",
        "# Funktion, die die Vorhersage für ein bestimmtes percentsalaryhike berechnet\n",
        "def predict_performance_rating(salary_hike):\n",
        "    return model.predict([[salary_hike]])[0]\n",
        "\n",
        "# Optimierung: Findet den percentsalaryhike, der PerformanceRating 4 erreicht\n",
        "def find_salary_hike_for_rating(target_rating):\n",
        "    low, high = 0, 100  # Annahme, dass der percentsalaryhike zwischen 0 und 100 liegt\n",
        "    tolerance = 0.01\n",
        "\n",
        "    while high - low > tolerance:\n",
        "        mid = (low + high) / 2\n",
        "        predicted_rating = predict_performance_rating(mid)\n",
        "\n",
        "        if predicted_rating < target_rating:\n",
        "            low = mid\n",
        "        else:\n",
        "            high = mid\n",
        "\n",
        "    return (low + high) / 2\n",
        "\n",
        "# Finde den percentsalaryhike, der PerformanceRating 4 ergibt\n",
        "required_salary_hike = find_salary_hike_for_rating(4)\n",
        "print(f\"Der erforderliche Salary Hike für PerformanceRating 4 ist: {required_salary_hike}\")\n"
      ],
      "metadata": {
        "id": "4EyXCvPLk3Zp"
      },
      "id": "4EyXCvPLk3Zp",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3 (ipykernel)",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.10.14"
    },
    "colab": {
      "provenance": [],
      "include_colab_link": true
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}