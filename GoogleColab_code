{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/ponkis01/BusinessAnalytics/blob/main/GoogleColab_code\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "f7d2f912-4bfc-4be4-b1dd-71da0c18195b",
      "metadata": {
        "id": "f7d2f912-4bfc-4be4-b1dd-71da0c18195b"
      },
      "source": [
        "# Cleaning"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f0587b3b-d0b5-4a03-95b9-806ba0958801",
      "metadata": {
        "id": "f0587b3b-d0b5-4a03-95b9-806ba0958801",
        "outputId": "d34754e2-97ff-4769-9a41-a0d321154dab",
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 329
        }
      },
      "outputs": [
        {
          "output_type": "error",
          "ename": "FileNotFoundError",
          "evalue": "[Errno 2] No such file or directory: '/content/WA_Fn-UseC_-HR-Employee-Attrition.xls'",
          "traceback": [
            "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
            "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
            "\u001b[0;32m<ipython-input-1-b7ab19b17b08>\u001b[0m in \u001b[0;36m<cell line: 6>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      4\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m \u001b[0;31m# Importieren des Datensatzes\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 6\u001b[0;31m \u001b[0mdf\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mpd\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mread_csv\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"/content/WA_Fn-UseC_-HR-Employee-Attrition.xls\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
            "\u001b[0;32m/usr/local/lib/python3.10/dist-packages/pandas/io/parsers/readers.py\u001b[0m in \u001b[0;36mread_csv\u001b[0;34m(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend)\u001b[0m\n\u001b[1;32m   1024\u001b[0m     \u001b[0mkwds\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mupdate\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkwds_defaults\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1025\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1026\u001b[0;31m     \u001b[0;32mreturn\u001b[0m \u001b[0m_read\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfilepath_or_buffer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mkwds\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1027\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1028\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.10/dist-packages/pandas/io/parsers/readers.py\u001b[0m in \u001b[0;36m_read\u001b[0;34m(filepath_or_buffer, kwds)\u001b[0m\n\u001b[1;32m    618\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    619\u001b[0m     \u001b[0;31m# Create the parser.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 620\u001b[0;31m     \u001b[0mparser\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mTextFileReader\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfilepath_or_buffer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwds\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    621\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    622\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0mchunksize\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0miterator\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.10/dist-packages/pandas/io/parsers/readers.py\u001b[0m in \u001b[0;36m__init__\u001b[0;34m(self, f, engine, **kwds)\u001b[0m\n\u001b[1;32m   1618\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1619\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mhandles\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mIOHandles\u001b[0m \u001b[0;34m|\u001b[0m \u001b[0;32mNone\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1620\u001b[0;31m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_engine\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_make_engine\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mengine\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1621\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1622\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0mclose\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.10/dist-packages/pandas/io/parsers/readers.py\u001b[0m in \u001b[0;36m_make_engine\u001b[0;34m(self, f, engine)\u001b[0m\n\u001b[1;32m   1878\u001b[0m                 \u001b[0;32mif\u001b[0m \u001b[0;34m\"b\"\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mmode\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1879\u001b[0m                     \u001b[0mmode\u001b[0m \u001b[0;34m+=\u001b[0m \u001b[0;34m\"b\"\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1880\u001b[0;31m             self.handles = get_handle(\n\u001b[0m\u001b[1;32m   1881\u001b[0m                 \u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1882\u001b[0m                 \u001b[0mmode\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;32m/usr/local/lib/python3.10/dist-packages/pandas/io/common.py\u001b[0m in \u001b[0;36mget_handle\u001b[0;34m(path_or_buf, mode, encoding, compression, memory_map, is_text, errors, storage_options)\u001b[0m\n\u001b[1;32m    871\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mioargs\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mencoding\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0;34m\"b\"\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mioargs\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmode\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    872\u001b[0m             \u001b[0;31m# Encoding\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 873\u001b[0;31m             handle = open(\n\u001b[0m\u001b[1;32m    874\u001b[0m                 \u001b[0mhandle\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    875\u001b[0m                 \u001b[0mioargs\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmode\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
            "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] No such file or directory: '/content/WA_Fn-UseC_-HR-Employee-Attrition.xls'"
          ]
        }
      ],
      "source": [
        "import pandas as pd\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Importieren des Datensatzes\n",
        "df = pd.read_csv(\"/content/WA_Fn-UseC_-HR-Employee-Attrition.xls\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "87403a5c-86c5-4cc3-9697-df276b8459d4",
      "metadata": {
        "id": "87403a5c-86c5-4cc3-9697-df276b8459d4"
      },
      "outputs": [],
      "source": [
        "# Einstellung um den ganzen datensatz zu sehen\n",
        "pd.set_option('display.max_columns', None)\n",
        "pd.set_option('display.expand_frame_repr', False)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c78f1898-066b-42db-bc20-a87dd603d3c5",
      "metadata": {
        "collapsed": true,
        "id": "c78f1898-066b-42db-bc20-a87dd603d3c5"
      },
      "outputs": [],
      "source": [
        "# Nach fehlenden Daten suchen\n",
        "df.isnull().sum()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "085a683c-8281-48ba-a1a3-1f424570ea26",
      "metadata": {
        "collapsed": true,
        "id": "085a683c-8281-48ba-a1a3-1f424570ea26"
      },
      "outputs": [],
      "source": [
        "import seaborn as sns\n",
        "\n",
        "# Identifizieren ob es eine Korrelation zwischen den verschiedenen Bezahlungen gibt gibt.\n",
        "# Falls es diese gibt k√∂nnte man die Bezahlung auch mit einer Variablen beschreiben um das Modell leichter interpretierbar zu machen.\n",
        "df2 = df[[\"DailyRate\", \"HourlyRate\", \"MonthlyRate\", \"MonthlyIncome\"]]\n",
        "correlation_matrix = df2.corr()\n",
        "plt.figure(figsize=(8, 6))\n",
        "sns.heatmap(correlation_matrix, annot=True, cmap=\"coolwarm\", fmt=\".2f\")\n",
        "plt.title(\"Correlation Matrix\")\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "73a118c9-bcdb-4a1f-8ad1-f98632accc22",
      "metadata": {
        "collapsed": true,
        "id": "73a118c9-bcdb-4a1f-8ad1-f98632accc22"
      },
      "outputs": [],
      "source": [
        "# Identifizieren ob es eine Korrelation zwischen YearsWithCurrManager, YearsInCurrentRole und YearsAtCompany gibt.\n",
        "# Da YearsAtCompany predicted wird wollen wir andere √§hnlche und stark korrelierende Variablen l√∂schen.\n",
        "\n",
        "df3 = df[[\"YearsWithCurrManager\", \"YearsInCurrentRole\", \"YearsAtCompany\"]]\n",
        "correlation_matrix = df3.corr()\n",
        "plt.figure(figsize=(8, 6))\n",
        "sns.heatmap(correlation_matrix, annot=True, cmap=\"coolwarm\", fmt=\".2f\")\n",
        "plt.title(\"Correlation Matrix\")\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b66153ad-babc-4d9f-af31-c9378acfbfd0",
      "metadata": {
        "id": "b66153ad-babc-4d9f-af31-c9378acfbfd0"
      },
      "outputs": [],
      "source": [
        "from sklearn.model_selection import train_test_split\n",
        "from sksurv.util import Surv\n",
        "\n",
        "# Droppen von Variable die nicht genutzt werden k√∂nnen\n",
        "df = df.drop(['EmployeeCount', 'EmployeeNumber', 'StandardHours', 'YearsWithCurrManager', 'YearsInCurrentRole'], axis=1)\n",
        "\n",
        "#Die Daten m√ºssen verwertbar sein d.h. fehlerfrei und einheitlich formatiert sein.\n",
        "#Unn√∂tige Daten werden entfernt.\n",
        "#Aufteilung in kategorische und numerische Spalten um diese sp√§ter besser verarbeiten zu k√∂nnen.\n",
        "\n",
        "# Konvertieren von gewissen Variablen zu kathegorischen Variablen\n",
        "categorical_columns = [\n",
        "    'Attrition', 'BusinessTravel', 'Department', 'Education', 'Gender',\n",
        "    'EducationField', 'JobRole', 'MaritalStatus', 'Over18', 'OverTime',\n",
        "    'StockOptionLevel', 'EnvironmentSatisfaction', 'JobInvolvement',\n",
        "    'JobSatisfaction', 'PerformanceRating', 'RelationshipSatisfaction',\n",
        "    'WorkLifeBalance'\n",
        "]\n",
        "df[categorical_columns] = df[categorical_columns].astype('category')\n",
        "\n",
        "# Skalieren der numerischen Werte\n",
        "variables_to_scale = [\n",
        "    'Age', 'DailyRate', 'DistanceFromHome', 'HourlyRate', 'MonthlyIncome',\n",
        "    'MonthlyRate', 'NumCompaniesWorked', 'PercentSalaryHike',\n",
        "    'TotalWorkingYears', 'TrainingTimesLastYear', 'YearsSinceLastPromotion'\n",
        "]\n",
        "df_mean = df[variables_to_scale].mean()\n",
        "df_std = df[variables_to_scale].std()\n",
        "df[variables_to_scale] = (df[variables_to_scale] - df_mean) / df_std\n",
        "\n",
        "# Encoden der kategorischen Variablen\n",
        "# Hier weisen wir jedem kategorischen Wert eine Zahl zu. Das erlaubt den Modellen leichter mit den Variablen zu arbeiten.\n",
        "from sklearn.preprocessing import LabelEncoder\n",
        "columns_to_encode = ['BusinessTravel', 'Department',\n",
        "                     'EducationField', 'Gender', 'JobRole',\n",
        "                     'MaritalStatus', 'OverTime', 'Over18', 'Attrition']\n",
        "label_encoder = LabelEncoder()\n",
        "for col in columns_to_encode:\n",
        "    df[col] = label_encoder.fit_transform(df[col])\n",
        "    df[col] = df[col].astype('category')\n",
        "\n",
        "\n",
        "# Strukturieren das Datensatzes in X und y (y Werte werden in einen strukturierten Array umgewandelt (Survival, Time)\n",
        "event_column = df['Attrition'].astype(int)\n",
        "time_column = df['YearsAtCompany']\n",
        "\n",
        "# da wir eine Survival analyse machen ist unser y Datensatz ein Array mit √úberleben(ja/nein) und √úberlebenszeit.\n",
        "survival_data = Surv.from_arrays(event=event_column, time=time_column)\n",
        "X = df.drop(['Attrition', 'YearsAtCompany'], axis=1)\n",
        "y = survival_data\n",
        "\n",
        "# Train und Test Aufteilung\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=12)\n",
        "\n",
        "y_train_event = y_train['event']\n",
        "y_train_time = y_train['time']\n",
        "y_test_event = y_test['event']\n",
        "y_test_time = y_test['time']"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "56e216b2-1cff-4628-b757-178f7bd3981d",
      "metadata": {
        "id": "56e216b2-1cff-4628-b757-178f7bd3981d"
      },
      "source": [
        "# XGBoost"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b2cf7fed-38a6-4554-81af-ede2d3841b54",
      "metadata": {
        "collapsed": true,
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "b2cf7fed-38a6-4554-81af-ede2d3841b54",
        "outputId": "89768309-a130-4f84-9115-2f6bf0a58ecc"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Concordance Index (Training): 0.879\n",
            "Concordance Index (Testing): 0.805\n"
          ]
        }
      ],
      "source": [
        "import xgboost as xgb\n",
        "from sksurv.metrics import concordance_index_censored\n",
        "\n",
        "# Initialisieren des Modells\n",
        "xgb_model = xgb.XGBRegressor(\n",
        "    enable_categorical=True,\n",
        "    # Das objective erlaubt uns aus dem standart XGB Modell eine Cox Survival Analyse zu machen.\n",
        "    objective='survival:cox',\n",
        ")\n",
        "xgb_model.fit(X_train, y_train_time, sample_weight=y_train_event)\n",
        "\n",
        "# Vorhersagen der Train und Test Risikowerte\n",
        "xgb_risk_scores_train = xgb_model.predict(X_train)\n",
        "xgb_risk_scores_test = xgb_model.predict(X_test)\n",
        "\n",
        "# Berechnen des Concordance Indexes\n",
        "xgb_c_index_train = concordance_index_censored(y_train_event, y_train_time, xgb_risk_scores_train)[0]\n",
        "xgb_c_index_test = concordance_index_censored(y_test_event, y_test_time, xgb_risk_scores_test)[0]\n",
        "\n",
        "print(f\"Concordance Index (Training): {xgb_c_index_train:.3f}\")\n",
        "print(f\"Concordance Index (Testing): {xgb_c_index_test:.3f}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "8c313d6c-7e3c-469d-b800-71eaf1ff281d",
      "metadata": {
        "id": "8c313d6c-7e3c-469d-b800-71eaf1ff281d"
      },
      "source": [
        "Der Concordance Index zeigt uns an, wie gut das Modell die Reihenfolge der \"√úberlebenszeiten\" der verschiedenen Angestellten vorhersagt. Er sagt uns, wie gut das Modell in der Lage ist, f√ºr zwei beliebig ausgew√§hlte Individuen die Rangfolge ihrer erwarteten √úberlebenszeiten oder Risiken korrekt vorherzusagen. Ein Wert von 0.5 w√ºrde also aussagen dass das Modell keine Predictive Power hat und ein Wert von 1 dass das Modell alle Reihenfolgen richtig verhersagt."
      ]
    },
    {
      "cell_type": "markdown",
      "id": "08dc0443-a477-44ed-9edd-24a8a9f01535",
      "metadata": {
        "id": "08dc0443-a477-44ed-9edd-24a8a9f01535"
      },
      "source": [
        "# XGBSE"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b89614d8-831b-483f-af98-084d81331f04",
      "metadata": {
        "collapsed": true,
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "b89614d8-831b-483f-af98-084d81331f04",
        "outputId": "438851ed-bfa6-4074-cfa4-8cb4f6fcacab"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "/usr/local/lib/python3.10/dist-packages/xgbse/non_parametric.py:61: FutureWarning: DataFrame.fillna with 'method' is deprecated and will raise in a future version. Use obj.ffill() or obj.bfill() instead.\n",
            "  return pd.DataFrame(C_exp).fillna(method=\"bfill\").fillna(method=\"ffill\").values\n",
            "/usr/local/lib/python3.10/dist-packages/xgbse/non_parametric.py:61: FutureWarning: DataFrame.fillna with 'method' is deprecated and will raise in a future version. Use obj.ffill() or obj.bfill() instead.\n",
            "  return pd.DataFrame(C_exp).fillna(method=\"bfill\").fillna(method=\"ffill\").values\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Concordance Index (Training): 0.907\n",
            "Concordance Index (Testing): 0.772\n"
          ]
        }
      ],
      "source": [
        "from xgbse import XGBSEKaplanNeighbors\n",
        "from xgbse.converters import convert_to_structured\n",
        "from xgbse.metrics import concordance_index\n",
        "\n",
        "# Initialisieren des Modells\n",
        "xgbse_model = XGBSEKaplanNeighbors(enable_categorical = True)\n",
        "xgbse_model.fit(X_train, y_train)\n",
        "\n",
        "# Vorhersagen der Train und Test Risikowerte\n",
        "xgb_risk_scores_train = xgbse_model.predict(X_train)\n",
        "xgb_risk_scores_test = xgbse_model.predict(X_test)\n",
        "\n",
        "# Berechnen des Concordance Indexes\n",
        "xgb_c_index_train = concordance_index(y_train, xgb_risk_scores_train)\n",
        "xgb_c_index_test = concordance_index(y_test, xgb_risk_scores_test)\n",
        "\n",
        "print(f\"Concordance Index (Training): {xgb_c_index_train:.3f}\")\n",
        "print(f\"Concordance Index (Testing): {xgb_c_index_test:.3f}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "fdbca0ec-5c8b-4894-b9de-67d35909faac",
      "metadata": {
        "id": "fdbca0ec-5c8b-4894-b9de-67d35909faac"
      },
      "source": [
        "# Random Survival Forest"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "Das RSF Modell ist eine statistische Methode, welche Ereigniszeiten modelliert und versucht die Dauer bis zum eintreffen des Ereignisses vorherzusagen. Es basiert auf Bootstrap-Sampling (Datensatz ins zuf√§llige Teile splitten), Baumerstellung (Baum splittet Daten basierend auf √úberlebensinformationen und speichert diese in den Bl√§ttern) und Aggregation (√úberlebenswahrscheinlichkeit eines neuen Datenpunkts wird als Durchschnitt der Vorhersagen aus allen B√§umen berechnet).\n",
        "\\\n",
        "Im Endeffekt sagt der Random Survival Forest f√ºr jede Beobachtung eine Hazard-Kurve vorher. Diese kann in eine Survival-Kurve umgewandelt werden, die die Wahrscheinlichkeit angibt, dass ein Individuum √ºber einen bestimmten Zeitpunkt hinaus √ºberlebt."
      ],
      "metadata": {
        "id": "csiUWuI8q99y"
      },
      "id": "csiUWuI8q99y"
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "3e3d1e52-c195-412a-b4c9-d8d072c7bcd0",
      "metadata": {
        "collapsed": true,
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "3e3d1e52-c195-412a-b4c9-d8d072c7bcd0",
        "outputId": "4ea4c6c6-f092-455e-cafd-3defa37b4f80"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Concordance Index (Train): 0.972\n",
            "Concordance Index (Test): 0.834\n"
          ]
        }
      ],
      "source": [
        "from sksurv.ensemble import RandomSurvivalForest\n",
        "from sksurv.util import Surv\n",
        "\n",
        "# Trainieren des Modells\n",
        "rsf_model = RandomSurvivalForest()\n",
        "rsf_model.fit(X_train, y_train)\n",
        "\n",
        "# Vorhersagen der Trainings- und Testdaten\n",
        "rsf_risk_scores_train = rsf_model.predict(X_train)\n",
        "rsf_risk_scores_test = rsf_model.predict(X_test)\n",
        "\n",
        "# Berechnen des C Indexes\n",
        "rsf_c_index_train = concordance_index_censored(y_train['event'], y_train['time'], rsf_risk_scores_train)[0]\n",
        "rsf_c_index_test = concordance_index_censored(y_test['event'], y_test['time'], rsf_risk_scores_test)[0]\n",
        "\n",
        "print(f\"Concordance Index (Training): {rsf_c_index_train:.3f}\")\n",
        "print(f\"Concordance Index (Testing): {rsf_c_index_test:.3f}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "cda10070-85f0-4f17-86dc-c97cbbd18d13",
      "metadata": {
        "id": "cda10070-85f0-4f17-86dc-c97cbbd18d13"
      },
      "source": [
        "Der Random Survival Forest schneidet ohne Tuning am besten von allen Modellen ab. Deswegen haben wir uns entschieden, mit diesem Modell weiterzuarbeiten."
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "# Tuning"
      ],
      "metadata": {
        "id": "satb56U9rFhX"
      },
      "id": "satb56U9rFhX"
    },
    {
      "cell_type": "markdown",
      "source": [
        "Da GridSearchCV weder nach dem C-Index optimieren kann noch strukturierte Arrays als Zielvariablen unterst√ºtzt, m√ºssen wir das Modell mit Hyperopt manuell optimieren.\n"
      ],
      "metadata": {
        "id": "Z3qW_1mBrB_D"
      },
      "id": "Z3qW_1mBrB_D"
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "a42de75d-c007-4689-9cb7-2ae7c03ef726",
      "metadata": {
        "collapsed": true,
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "a42de75d-c007-4689-9cb7-2ae7c03ef726",
        "outputId": "a9ee1ed2-5688-4382-fcda-81cce769b5b1"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 50/50 [17:01<00:00, 20.42s/trial, best loss: -0.8704109082756183]\n"
          ]
        }
      ],
      "source": [
        "from hyperopt import fmin, tpe, hp, Trials\n",
        "from sksurv.metrics import concordance_index_censored\n",
        "from sksurv.ensemble import RandomSurvivalForest\n",
        "from sklearn.model_selection import KFold\n",
        "import numpy as np\n",
        "\n",
        "# Zielfunktion erstellen\n",
        "def objective(params):\n",
        "    # Erstellen des Random Survival Forest mit variablen Parametern\n",
        "    model = RandomSurvivalForest(\n",
        "        n_estimators=int(params['n_estimators']),\n",
        "        max_depth=int(params['max_depth']) if params['max_depth'] is not None else None,\n",
        "        min_samples_split=int(params['min_samples_split']),\n",
        "        min_samples_leaf=int(params['min_samples_leaf']),\n",
        "        max_features=params['max_features'],\n",
        "        random_state=12\n",
        "    )\n",
        "\n",
        "    # Cross Validation\n",
        "    kf = KFold(n_splits=5, shuffle=True, random_state=12)\n",
        "    c_index_scores = []\n",
        "\n",
        "    for train_index, test_index in kf.split(X_train):\n",
        "        X_train_cv, X_test_cv = X.iloc[train_index], X.iloc[test_index]\n",
        "        y_train_cv, y_test_cv = y[train_index], y[test_index]\n",
        "\n",
        "        model.fit(X_train_cv, y_train_cv)\n",
        "        predictions = model.predict(X_test_cv)\n",
        "\n",
        "        c_index = concordance_index_censored(y_test_cv['event'], y_test_cv['time'], predictions)[0]\n",
        "        c_index_scores.append(c_index)\n",
        "\n",
        "    # Durchschnitt des Konkordanz-Index f√ºr alle CV Folds berechnen\n",
        "    mean_c_index = np.mean(c_index_scores)\n",
        "\n",
        "    # Hyperopt minimiert die Zielfunktion, also geben wir den negativen C-Index an\n",
        "    return -mean_c_index\n",
        "\n",
        "# Hyperparametergrid erstellen\n",
        "space = {\n",
        "    'n_estimators': hp.choice('n_estimators', [100, 200, 500, 1000]),\n",
        "    'max_depth': hp.choice('max_depth', [None, 10, 20, 30, 50]),\n",
        "    'min_samples_split': hp.quniform('min_samples_split', 2, 20, 1),\n",
        "    'min_samples_leaf': hp.quniform('min_samples_leaf', 1, 10, 1),\n",
        "    'max_features': hp.choice('max_features', ['sqrt', 'log2', None])\n",
        "}\n",
        "\n",
        "# Optimierung starten\n",
        "trials = Trials()\n",
        "best = fmin(\n",
        "    fn=objective,\n",
        "    space=space,\n",
        "    algo=tpe.suggest,\n",
        "    max_evals=50,\n",
        "    trials=trials\n",
        ")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c85f8fee-0c67-4b73-9928-6b3de1340f22",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "c85f8fee-0c67-4b73-9928-6b3de1340f22",
        "outputId": "e07003c4-f6a8-4412-9237-8ca2ce8268b1"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "{'bootstrap': True,\n",
              " 'low_memory': False,\n",
              " 'max_depth': None,\n",
              " 'max_features': 'log2',\n",
              " 'max_leaf_nodes': None,\n",
              " 'max_samples': None,\n",
              " 'min_samples_leaf': 1,\n",
              " 'min_samples_split': 2,\n",
              " 'min_weight_fraction_leaf': 0.0,\n",
              " 'n_estimators': 1000,\n",
              " 'n_jobs': None,\n",
              " 'oob_score': False,\n",
              " 'random_state': 12,\n",
              " 'verbose': 0,\n",
              " 'warm_start': False}"
            ]
          },
          "metadata": {},
          "execution_count": 17
        }
      ],
      "source": [
        "# Fitting des Modells mit optimalen Prametern\n",
        "optimal_model = RandomSurvivalForest(\n",
        "    n_estimators=[100, 200, 500, 1000][best['n_estimators']],\n",
        "    max_depth=[None, 10, 20, 30, 50][best['max_depth']],\n",
        "    min_samples_split=int(best['min_samples_split']),\n",
        "    min_samples_leaf=int(best['min_samples_leaf']),\n",
        "    max_features=['sqrt', 'log2', None][best['max_features']],\n",
        "    random_state=12\n",
        ")\n",
        "optimal_model.fit(X_train, y_train)\n",
        "optimal_model.get_params()"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "# Evaluieren des Modells"
      ],
      "metadata": {
        "id": "fvAHhc48rJCi"
      },
      "id": "fvAHhc48rJCi"
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "dc984b11-ce8b-4a50-ba0e-47c3371ef9b6",
      "metadata": {
        "collapsed": true,
        "id": "dc984b11-ce8b-4a50-ba0e-47c3371ef9b6"
      },
      "outputs": [],
      "source": [
        "# Visualisieren der Verteilung der Risiko Scores\n",
        "# Wir schauen uns die Riskiowerte an um zu entschieden ob es besonders hohe Werte gibt.\n",
        "# Wenn man exp(Risikowert) berechnet erh√§lt man das Hazard Ratio des Individuums relativ zum Baseline-Risiko\n",
        "risk_scores = optimal_model.predict(X_train)\n",
        "plt.hist(risk_scores, bins=50, edgecolor='k')\n",
        "plt.title(\"Distribution of Risk Scores\")\n",
        "plt.xlabel(\"Risk Score\")\n",
        "plt.ylabel(\"Frequency\")\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "Unsere Risikowerte sind relative hoch. Wir interpretieren daraus, dass es starke Unterschiede zwischen den Individuen gibt die sich auf die Survival time auswirken.\n",
        "Um zu schuane ob es Ausrei√üer in den Daten gibt schauen wir uns die Individuen mit den h√∂chsten Risikowerten an."
      ],
      "metadata": {
        "id": "yP-5P3r5jiRC"
      },
      "id": "yP-5P3r5jiRC"
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b3cff105-a79e-46aa-bbfc-2b01c9b38697",
      "metadata": {
        "id": "b3cff105-a79e-46aa-bbfc-2b01c9b38697"
      },
      "outputs": [],
      "source": [
        "X_test[rsf_risk_scores_test > 20]"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "47fd6efa-bf3c-4bfa-b20c-e0b4028601d7",
      "metadata": {
        "id": "47fd6efa-bf3c-4bfa-b20c-e0b4028601d7"
      },
      "source": [
        "Es gibt keine Besonderheiten oder extremen Werte bei Individuen mit hohen Risikowerten."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "3586ff75-b9cc-451b-8e1e-07be34f69a4c",
      "metadata": {
        "id": "3586ff75-b9cc-451b-8e1e-07be34f69a4c"
      },
      "outputs": [],
      "source": [
        "from sklearn.inspection import permutation_importance\n",
        "\n",
        "# Bestimmen der Permutation Importances\n",
        "perm_importance = permutation_importance(optimal_model, X_test, y_test, n_repeats=10, random_state=42)\n",
        "\n",
        "# Erstellen einen Dataframes von Feature und Importance\n",
        "feature_importance_df = pd.DataFrame({\n",
        "    \"Feature\": X_test.columns,\n",
        "    \"Importance\": perm_importance.importances_mean\n",
        "})\n",
        "feature_importance_df = feature_importance_df.sort_values(by=\"Importance\", ascending=False)\n",
        "\n",
        "# Erstellen des Permutation Importance Plots\n",
        "plt.figure(figsize=(10, 6))\n",
        "plt.barh(feature_importance_df[\"Feature\"], feature_importance_df[\"Importance\"], color=\"skyblue\")\n",
        "plt.xlabel(\"Mean Ver√§nderung des Concordance Indexes\")\n",
        "plt.ylabel(\"Feature\")\n",
        "plt.title(\"Permutation Wichtigkeit f√ºr den Random Survival Forest\")\n",
        "plt.gca().invert_yaxis()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "Im folgenden Teil versuchen wir, die vorhergesagte durchschnittliche √úberlebenszeit des gesamten Testdatensatzes mit der tats√§chlichen √úberlebenszeit zu vergleichen.\n",
        "\\\n",
        "Der Random Survival Forest sch√§tzt lediglich eine Hazard-Funktion, die in eine Survival-Kurve umgewandelt werden muss.\n",
        "\\\n",
        "Au√üerdem verf√ºgen wir nicht √ºber die direkte √úberlebenszeit f√ºr alle Individuen im Datensatz, da viele noch bei IBM arbeiten. Deshalb m√ºssen wir die durchschnittliche √úberlebenszeit mithilfe des Kaplan-Meier-Fitters berechnen."
      ],
      "metadata": {
        "id": "FsA7CBYVm71x"
      },
      "id": "FsA7CBYVm71x"
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7f1e82fb-2c33-4284-9330-dae1084bb391",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "7f1e82fb-2c33-4284-9330-dae1084bb391",
        "outputId": "8331385e-4b3b-4602-881d-81acaa2b5b7b"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Vorhergesagte Mean Survival Time: 29.62\n",
            "Bereinigte Beobachtete Mean Survival Time: 27.17\n"
          ]
        }
      ],
      "source": [
        "from lifelines import KaplanMeierFitter\n",
        "import numpy as np\n",
        "\n",
        "# Vorhersage der √úberlebenskurven f√ºr jede Person im Test Datensatz\n",
        "predicted_survival_curves = optimal_model.predict_survival_function(X_test)\n",
        "\n",
        "# Berechnung der erwarteten √úberlebenszeit f√ºr jede Person\n",
        "expected_survival_times = []\n",
        "for survival_curve in predicted_survival_curves:\n",
        "    time_points = survival_curve.x\n",
        "    survival_probs = survival_curve.y\n",
        "    time_diffs = np.diff(np.append(0, time_points))\n",
        "    expected_time = np.sum(survival_probs * time_diffs)\n",
        "    expected_survival_times.append(expected_time)\n",
        "\n",
        "# Berechnung der mean vorhergesagten √úberlebenszeit\n",
        "expected_survival_times = np.array(expected_survival_times)\n",
        "predicted_mean_time = expected_survival_times.mean()\n",
        "print(f\"Vorhergesagte Mean Survival Time: {predicted_mean_time:.2f}\")\n",
        "\n",
        "# Kaplan Meier Sch√§tzung (Fitter)\n",
        "# Ist eine statistische Methode zur Sch√§tzung der √úberlebenswahrscheinlichtkeit (Eintreffen eines Ereignisses), √ºber die Zeit.\n",
        "# Wir benutzen diese Mehtode da mna nicht dirkt die beobachtete √úberlebenszeit berechnen kann, da viele Angestellte noch im Unternehmen sind.\n",
        "#  ->  Liefert eine Treppenfunktion, welche bei jedem Ereigniszeitpunkt abnimmt.\n",
        "#  ->  Ber√ºcksichtigt zensierte Daten (Daten bei denen das Ereignis nicht im Beobachtungszeitraum eintritt) und entfernt diese aus der Berechnung.\n",
        "\n",
        "# Anpassen des Kaplan-Meier-Modells an die Test Daten\n",
        "kmf_test = KaplanMeierFitter()\n",
        "kmf_test.fit(y_test_time, event_observed=y_test_event)\n",
        "\n",
        "# Extraktion der √úKaplan-Meier-bereinigten beobachteten mittleren √úberlebenszeit\n",
        "survival_probs = kmf_test.survival_function_.values.flatten()\n",
        "time_points = kmf_test.survival_function_.index.values\n",
        "time_diffs = np.diff(np.append(0, time_points))\n",
        "adjusted_mean_time = np.sum(survival_probs * time_diffs)\n",
        "print(f\"Bereinigte Beobachtete Mean Survival Time: {adjusted_mean_time:.2f}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "Im folgenden Teil versuchen wir, die Survival Analysis als Klassifizierungsproblem umzugestalten. Dabei schauen wir, ob √ºber einen gewissen Zeitraum die Angestellten tats√§chlich im Unternehmen geblieben sind. Das Modell mithilfe des Kaplan Meier Fitters sagt gleichzeitig die √úberlebenswahrscheinlichkeit f√ºr diesen Zeitraum aus. Bei einer Wahrscheinlichkeit von 0.5 und dar√ºber wird also vorhergesagt, dass die Person √ºberlebt. So k√∂nnen wir Metriken wie Accuracy etc. berechnen. Wir nehmen heirf√ºr den ganzen Datensatz, da die Anzahl der Leute die das Unternehmen bereits verlassen, sowieso relativ klein ist, w√§re es nicht sinnvoll sich auf den Testdatensatz zu beschr√§nken."
      ],
      "metadata": {
        "id": "tOgLWAfTnNu0"
      },
      "id": "tOgLWAfTnNu0"
    },
    {
      "cell_type": "code",
      "source": [
        "from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score\n",
        "\n",
        "# Spezifische Jahre definieren\n",
        "time_points = [1, 2, 5]  # Zeitpunkte in Jahren\n",
        "results = []\n",
        "\n",
        "predicted_survival_curves_x = optimal_model.predict_survival_function(X)\n",
        "\n",
        "for t in time_points:\n",
        "    # √úberlebenswahrscheinlichkeiten f√ºr den spezifischen Zeitpunkt berechnen\n",
        "    predicted_probs_at_time = np.array([sf(t) for sf in predicted_survival_curves_x])\n",
        "\n",
        "    # Maske f√ºr g√ºltige F√§lle\n",
        "    # Jeder der t oder weniger Jahre im Unternehmen war und bereits gegangen ist.\n",
        "    actual_status_at_time = np.where((y[\"time\"] <= t) & (y[\"event\"] == 0), 0, 1)\n",
        "    # √úber einer Wahrscheinlichkeit von 0.5 wird als survival und darunter als nicht survival Klassifiziert\n",
        "    actual_predictions = (predicted_probs_at_time >= 0.5).astype(int)\n",
        "\n",
        "    # Berechnen der Scores\n",
        "    accuracy = accuracy_score(actual_status_at_time, actual_predictions)\n",
        "    precision = precision_score(actual_status_at_time, actual_predictions, zero_division=0)\n",
        "    recall = recall_score(actual_status_at_time, actual_predictions, zero_division=0)\n",
        "\n",
        "    results.append({\n",
        "        \"time\": t,\n",
        "        \"Accuracy\": accuracy,\n",
        "        \"Precision\": precision,\n",
        "        \"Recall\": recall,\n",
        "    })\n",
        "\n",
        "# Anziegen der Resultate\n",
        "for res in results:\n",
        "    print(f\"Time {res['time']} year(s): \"\n",
        "          f\"Accuracy={res['Accuracy']:.2f}, \"\n",
        "          f\"Precision={res['Precision']:.2f}, \"\n",
        "          f\"Recall={res['Recall']:.2f}, \")"
      ],
      "metadata": {
        "id": "TYKv8aqXyi6N"
      },
      "id": "TYKv8aqXyi6N",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "id": "f55beb13-92f2-49b1-ae95-e9c8552b1cf7",
      "metadata": {
        "id": "f55beb13-92f2-49b1-ae95-e9c8552b1cf7"
      },
      "source": [
        "Die Accuracy und die Precision des Modells starten mit guten Werten nehmen aber zunehmend ab, das Modell ist somit nur m√§√üig daf√ºr geeignet Vorhersagen √ºber l√§ngere Zeitr√§ume zu treffen. Wobei der Recall relativ hoch bleibt, das Modell erkennt also die Personen die gehen wollen aber bewertet auch viele die nicht gehen wollen als positives, es gibt also viele falsche Positive."
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c5a65b04-fd08-4094-8da8-52ed4faf1966",
      "metadata": {
        "id": "c5a65b04-fd08-4094-8da8-52ed4faf1966"
      },
      "source": [
        "# Verbesserung der Durchschnitts√ºberlebenszeit"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "In folgendem Teil suchen wir uns eine Person aus dem Trainingsdatensatz heraus. F√ºr diese Person berechnen wir die vorhergesagte durchschnittliche √úberlebenswahrscheinlichkeit und versuchen zu ermitteln, mit welchen Ver√§nderungen von Variablen man eine l√§ngere durchschnittliche √úberlebenswahrscheinlichkeit erzielen kann. Hierbei beschr√§nken wir uns auf Variablen, die der Arbeitgeber ver√§ndern kann."
      ],
      "metadata": {
        "id": "GbZk667QoR3W"
      },
      "id": "GbZk667QoR3W"
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d79427a5-32b1-4e3e-aaf6-ff4ba16377fb",
      "metadata": {
        "id": "d79427a5-32b1-4e3e-aaf6-ff4ba16377fb"
      },
      "outputs": [],
      "source": [
        "# Erstellen einer einzigen Observation (Person)\n",
        "person_number = 1\n",
        "person = X_train.iloc[[person_number]]\n",
        "t_condition = y_train['time'][person_number]"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "6ed135e0-454b-4020-9d0b-6774719b16de",
      "metadata": {
        "id": "6ed135e0-454b-4020-9d0b-6774719b16de",
        "outputId": "24534a43-07b2-4769-ecfd-34ba6e9e840a"
      },
      "outputs": [
        {
          "data": {
            "text/plain": [
              "9.63862308196837"
            ]
          },
          "execution_count": 28,
          "metadata": {},
          "output_type": "execute_result"
        }
      ],
      "source": [
        "  from lifelines import KaplanMeierFitter\n",
        "\n",
        "  # Anpassen des Kaplan-Meier-Modells an die Trainings Daten\n",
        "  kmf_train = KaplanMeierFitter()\n",
        "  kmf_train.fit(y_train_time, event_observed=y_train_event)\n",
        "\n",
        "  # Vorhersage des urspr√ºnglichen Risikoscores und der Hazardratio\n",
        "  original_risk_score = optimal_model.predict(person)\n",
        "  original_hazard_ratio = np.exp(original_risk_score)\n",
        "\n",
        "  # Extrahiere die Basis-√úberlebenskurve\n",
        "  baseline_times = kmf_train.survival_function_.index.values  # Zeitpunkte der Basis-√úberlebensfunktion\n",
        "  baseline_survival = kmf_train.survival_function_.values.flatten()\n",
        "\n",
        "  # Erstellen einer Funktion umd dei verbeleibende √úberlebenszeit zu berechnen -> f√ºr jede person die weitere Zeit im unternehmen\n",
        "  def compute_conditional_expected_time(hazard_ratio, baseline_survival, baseline_times, t_condition):\n",
        "\n",
        "      # Finden der √úberlebenswahrscheinlichkeit bei t_condition\n",
        "      idx_condition = np.searchsorted(baseline_times, t_condition, side=\"right\") - 1\n",
        "      survival_prob_at_t_condition = baseline_survival[idx_condition]\n",
        "\n",
        "      # Passe die √úberlebenswahrscheinlichkeiten der Basisfunktion mithilfe der Hazardratio des Individuums an\n",
        "      adjusted_survival_probs = (baseline_survival / survival_prob_at_t_condition) ** hazard_ratio\n",
        "      adjusted_survival_probs[baseline_times <= t_condition] = 0\n",
        "\n",
        "      # Berechne die bedingte erwartete √úberlebenszeit\n",
        "      time_diffs = np.diff(np.append(0, baseline_times))\n",
        "      conditional_expected_time = np.sum(adjusted_survival_probs * time_diffs)\n",
        "      return conditional_expected_time\n",
        "\n",
        "  # Anwenden der Funktion\n",
        "  conditional_expected_survival_time = compute_conditional_expected_time(\n",
        "      original_hazard_ratio, baseline_survival, baseline_times, t_condition\n",
        "  )\n",
        "  conditional_expected_survival_time"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "7cd0b206-628f-49b3-bfd9-993e42ae41a7",
      "metadata": {
        "collapsed": true,
        "id": "7cd0b206-628f-49b3-bfd9-993e42ae41a7",
        "outputId": "f4bdcadd-648f-4bbb-eefa-91f3d7cdd5f0"
      },
      "outputs": [
        {
          "name": "stdout",
          "output_type": "stream",
          "text": [
            "Ver√§nderung f√ºr die l√§ngste √úberlebenszeit: no_overtime\n"
          ]
        }
      ],
      "source": [
        "# Bef√∂rderung: YearsSinceLastPromotion, JobLevel\n",
        "person_higher_joblevel = person.copy()\n",
        "\n",
        "person_higher_joblevel['JobLevel'] = person_higher_joblevel['JobLevel'].astype(int)\n",
        "if (person_higher_joblevel['JobLevel'] != 5).any():\n",
        "    person_higher_joblevel['JobLevel'] += 1\n",
        "    person_higher_joblevel['YearsSinceLastPromotion'] = (0 - df_mean['YearsSinceLastPromotion']) / df_std['YearsSinceLastPromotion']\n",
        "person_higher_joblevel['JobLevel'] = person_higher_joblevel['JobLevel'].astype('category')\n",
        "\n",
        "changed_risk_score = optimal_model.predict(person_higher_joblevel)\n",
        "changed_hazard_ratio = np.exp(changed_risk_score)\n",
        "\n",
        "conditional_expected_survival_time_higher_joblevel = compute_conditional_expected_time(\n",
        "    changed_hazard_ratio, baseline_survival, baseline_times, t_condition\n",
        ")\n",
        "\n",
        "# OverTime\n",
        "person_no_overtime = person.copy()\n",
        "person_no_overtime['OverTime'] = 0\n",
        "person_no_overtime['OverTime'] = person_no_overtime['OverTime'].astype('category')\n",
        "\n",
        "changed_risk_score = optimal_model.predict(person_no_overtime)\n",
        "changed_hazard_ratio = np.exp(changed_risk_score)\n",
        "\n",
        "conditional_expected_survival_time_no_overtime = compute_conditional_expected_time(\n",
        "    changed_hazard_ratio, baseline_survival, baseline_times, t_condition\n",
        ")\n",
        "\n",
        "# Environment Satisfaction\n",
        "person_higher_environment_satisfaction = person.copy()\n",
        "\n",
        "person_higher_environment_satisfaction['EnvironmentSatisfaction'] = person_higher_environment_satisfaction['EnvironmentSatisfaction'].astype(int)\n",
        "if (person_higher_environment_satisfaction['EnvironmentSatisfaction'] != 4).any():\n",
        "    person_higher_environment_satisfaction['EnvironmentSatisfaction'] += 1\n",
        "person_higher_environment_satisfaction['EnvironmentSatisfaction'] = person_higher_environment_satisfaction['EnvironmentSatisfaction'].astype('category')\n",
        "\n",
        "changed_risk_score = optimal_model.predict(person_higher_environment_satisfaction)\n",
        "changed_hazard_ratio = np.exp(changed_risk_score)\n",
        "\n",
        "conditional_expected_survival_time_higher_environment_satsfaction = compute_conditional_expected_time(\n",
        "    changed_hazard_ratio, baseline_survival, baseline_times, t_condition\n",
        ")\n",
        "\n",
        "# StockOptionLevel\n",
        "person_higher_stockoption = person.copy()\n",
        "\n",
        "person_higher_stockoption['StockOptionLevel'] = person_higher_stockoption['StockOptionLevel'].astype(int)\n",
        "if (person_higher_stockoption['StockOptionLevel'] != 3).any():\n",
        "    person_higher_stockoption['StockOptionLevel'] += 1\n",
        "person_higher_stockoption['StockOptionLevel'] = person_higher_stockoption['StockOptionLevel'].astype('category')\n",
        "\n",
        "changed_risk_score = optimal_model.predict(person_higher_stockoption)\n",
        "changed_hazard_ratio = np.exp(changed_risk_score)\n",
        "\n",
        "conditional_expected_survival_time_higher_stockoption = compute_conditional_expected_time(\n",
        "    changed_hazard_ratio, baseline_survival, baseline_times, t_condition\n",
        ")\n",
        "\n",
        "\n",
        "# JobSatisfaction\n",
        "person_higher_jobsatisfaction = person.copy()\n",
        "\n",
        "person_higher_jobsatisfaction['JobSatisfaction'] = person_higher_jobsatisfaction['JobSatisfaction'].astype(int)\n",
        "if (person_higher_jobsatisfaction['JobSatisfaction'] != 4).any():\n",
        "    person_higher_jobsatisfaction['JobSatisfaction'] += 1\n",
        "person_higher_jobsatisfaction['JobSatisfaction'] = person_higher_jobsatisfaction['JobSatisfaction'].astype('category')\n",
        "\n",
        "changed_risk_score = optimal_model.predict(person_higher_jobsatisfaction)\n",
        "changed_hazard_ratio = np.exp(changed_risk_score)\n",
        "\n",
        "conditional_expected_survival_time_jobsatisfaction = compute_conditional_expected_time(\n",
        "    changed_hazard_ratio, baseline_survival, baseline_times, t_condition\n",
        ")\n",
        "conditional_expected_survival_time_jobsatisfaction\n",
        "\n",
        "\n",
        "def get_max_variable_name_from_values(**kwargs):\n",
        "    max_variable = max(kwargs, key=kwargs.get)  # Get the key with the maximum value\n",
        "    return max_variable\n",
        "# Finden der l√§ngsten \"√úberlebenszeit\"\n",
        "max_variable = get_max_variable_name_from_values(\n",
        "    no_overtime=conditional_expected_survival_time_no_overtime,\n",
        "    higher_jobsatisfaction=conditional_expected_survival_time_jobsatisfaction,\n",
        "    promotion=conditional_expected_survival_time_higher_joblevel,\n",
        "    higher_environment_satisfaction=conditional_expected_survival_time_higher_environment_satsfaction,\n",
        "    higher_stockoption_level=conditional_expected_survival_time_higher_stockoption\n",
        ")\n",
        "\n",
        "print(f\"Ver√§nderung f√ºr die l√§ngste √úberlebenszeit: {max_variable}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "Leider trifft das Modell bei den meisten Personen die gleiche Aussage, und zwar, dass Overtime verringert werden soll. Wir haben dieses Tool also nicht mit auf die Website √ºbernommen. Auf der Website kann man selbst die Variablen jeder Person anpassen und beobachten, wie sich dies auf die durchschnittliche √úberlebenszeit auswirkt."
      ],
      "metadata": {
        "id": "JiUK0rg9pYpO"
      },
      "id": "JiUK0rg9pYpO"
    },
    {
      "cell_type": "markdown",
      "id": "33259603-9c84-447f-9ef2-7e63c5f6fec7",
      "metadata": {
        "id": "33259603-9c84-447f-9ef2-7e63c5f6fec7"
      },
      "source": [
        "# Visualisierung der Survival Curve"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f92a6ff4-74ca-4af6-864a-6a18114098de",
      "metadata": {
        "collapsed": true,
        "id": "f92a6ff4-74ca-4af6-864a-6a18114098de",
        "outputId": "878ac841-12bd-4440-e061-51ba9961a9c0"
      },
      "outputs": [
        {
          "data": {
            "image/png": "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kNq3b6+dO3c69JHd72Nn3oecjvN9+/bZz/gFBwcrOjpaycnJDutevnxZQ4YMUUhIiAIDA/XQQw/pyJEj+b6OKzIyUh9//LFSU1M1efJke3tucrJmzRr72ejo6Gj7+56Znx9//FGPPfaYypcvLx8fH0VERGjYsGG6fPmyQww3+0xnutnvoD59+mjGjBmSHIf6Au7CmSvgFoqMjNSGDRv066+/6u677za178cee0xVqlTRa6+9JsMw9OCDD2rEiBGaP3++/QtQpvnz56tdu3YqUaJEln6sVqs6d+6sRYsW6f3333f4S/fixYuVkpJiH0aSlJSkDz/8UN27d1e/fv104cIFzZo1S1FRUdq8ebPTw0Uyv7D27NnTyb3PnQkTJsjb21vDhw9XSkqKqlevrkqVKmn+/Pnq3bu3w7Lx8fEqUaKEoqKiJEmJiYlq3LixvcgJDQ3V0qVL1bdvXyUlJWno0KHZbjM0NFSffvqpXn31VV28eFETJ06UJN15550yDEMPPfSQVq9erb59+6p27dpavny5nn/+eR05ciTLEMJVq1Zp/vz5iomJUUhISI6TkEybNk2DBw9WQECAXnrpJUlZh0YNHjxYJUqUUFxcnP78809NmzZNMTExio+Pty/z6aefqnfv3oqKitLrr7+u5ORkvffee2rWrJl++umnXE2CcuHCBZ06dcqhrWTJkjc8a3D9sSxJXbp00W+//abBgwerQoUKOnHihBISEnT48GFVqFAhV/ucG2fPntXZs2ftw81+++033XPPPSpbtqxGjhypYsWKaf78+erUqZMWLlyozp07O6w/cOBAhYaGauzYsbp06ZIkqX///vryyy8VExOj6tWr6/Tp01q3bp12796tunXrSrpanEVHR6tBgwaaOHGiEhMT9fbbb+u///2vfvrpJ4c/yKSnpysqKkqNGjXSm2++qe+//15TpkxR5cqVNWDAAKf3WZImTZokDw8PDR8+XOfPn9fkyZP1xBNPaNOmTTmu88gjj+iPP/7Q559/rrfeekshISGSrh7zmdatW6dFixZp4MCBCgwM1DvvvKMuXbro8OHDuu222yTl/bPljOs/+97e3tq1a5cWL16sxx57TBUrVlRiYqLef/99tWjRQrt27VKZMmVu2Gd+34fHH39cFStW1MSJE7V9+3Z9+OGHKlWqlMPZ+T59+mj+/Pnq2bOnGjdurLVr1+qBBx7Idz4kqUmTJqpcubISEhLsbQcOHLhpTu688069/PLLGjt2rJ555hk1b95cktS0aVNJV/9IkJycrAEDBui2227T5s2bNX36dP39999asGCBfVs3+0xLufsd9K9//UtHjx5VQkKCPv30U1NyA+SLAeCWWbFiheHp6Wl4enoaTZo0MUaMGGEsX77cSE1NdVju4MGDhiTjo48+ytKHJCMuLs7+PC4uzpBkdO/ePcuyTZo0MerVq+fQtnnzZkOS8cknn9jbevfubURGRtqfL1++3JBk/Oc//3FYt0OHDkalSpXsz9PS0oyUlBSHZc6ePWuEhYUZTz311A3jzk6dOnWM4ODgGy5zrcjISKN3795Z2lu0aGG0aNHC/nz16tWGJKNSpUpGcnKyw7KjRo0yrFarcebMGXtbSkqKUbx4cYd96Nu3r1G6dGnj1KlTDut369bNCA4OztJvdjHdddddDm2LFy82JBmvvPKKQ/ujjz5qWCwWY9++ffY2SYaHh4fx22+/3XA7me666y6HHGT66KOPDElGmzZtjIyMDHv7sGHDDE9PT+PcuXOGYRjGhQsXjOLFixv9+vVzWP/48eNGcHBwlvbrZeY8u8fBgwft+5SbY/ns2bOGJOONN97I0z7nRJLRt29f4+TJk8aJEyeMTZs2Ga1btzYkGVOmTDEMwzBat25t1KhRw7hy5Yp9vYyMDKNp06ZGlSpV7G2ZeW3WrJmRlpbmsJ3g4GBj0KBBOcaRmppqlCpVyrj77ruNy5cv29u//fZbQ5IxduxYe1vv3r0NScbLL7/s0EedOnWyfNazk9Nn484773T4LL/99tuGJOOXX365YX9vvPGGw3t6LUmGt7e3w3G8c+dOQ5Ixffp0e1t+P1uZTp48meWYutFn/8qVK0Z6erpD28GDBw0fHx+H/Gb3+9iZ9yGn4/z635GdO3c2brvtNvvzbdu2GZKMoUOHOizXp0+fXP0+zYz7Rp+bhx9+2JBknD9/3jCM3Odky5YtOf4fld37NXHiRMNisRiHDh0yDCN3n2lnfgcNGjTI4CstCgqGBQK3UNu2bbVhwwY99NBD2rlzpyZPnqyoqCiVLVs2yzAjZ/Xv3z9LW9euXbVt2zbt37/f3hYfHy8fHx89/PDDOfbVqlUrhYSEOJzFOHv2rBISEtS1a1d7m6enp/3MVkZGhs6cOaO0tDTVr18/y5Cn3EhKSlJgYKDT6+VW79695efn59DWtWtX2Ww2LVq0yN62YsUKnTt3zr6vhmFo4cKF6tixowzD0KlTp+yPqKgonT9/Pk/7+91338nT01NDhgxxaH/uuedkGIaWLl3q0N6iRQtVr17d6e1k55lnnnEYOtO8eXOlp6fbh5EmJCTo3Llz6t69u8P+enp6qlGjRrke+jl27FglJCQ4PMLDw2+4zvXHsp+fn7y9vbVmzRr7UFazzJo1S6GhoSpVqpQaNWqk//73v4qNjdXQoUN15swZrVq1So8//rj9DNypU6d0+vRpRUVFae/evVmG7fXr10+enp4ObcWLF9emTZtynOly69atOnHihAYOHOhwfc4DDzygatWqacmSJVnWuT5HzZs314EDB/KaBkVHRzucpc48G5GfPiWpTZs2qly5sv15zZo1FRQUZO/XVZ+t62X32ffx8bGfQU1PT9fp06cVEBCgqlWr5nqb+Xkfslv39OnTSkpKkiT78MmBAwc6LGfmxEcBAQGSrp5hlszJybV5vnTpkk6dOqWmTZvKMAz99NNP9mVu9pk263cQcKsxLBC4xRo0aKBFixYpNTVVO3fu1FdffaW33npLjz76qHbs2JHnL88VK1bM0vbYY48pNjZW8fHxevHFF2UYhhYsWKD27dsrKCgox768vLzUpUsXzZs3TykpKfLx8dGiRYtks9kciitJmjNnjqZMmaLff/9dNpvthvHczLVfulwhu5hq1aqlatWqKT4+Xn379pV0tQANCQlRq1atJEknT57UuXPn9H//93/6v//7v2z7zsuEJIcOHVKZMmWyFJR33nmn/fWbxZ9X5cuXd3ieOUQ084vO3r17Jcmeg+vd6Pi5Vo0aNdSmTRunYrt+P318fPT666/rueeeU1hYmBo3bqwHH3xQvXr1ummhdjMPP/ywYmJiZLFYFBgYqLvuuss+CcW+fftkGIbGjBmjMWPGZLv+iRMnVLZs2Rxjl6TJkyerd+/eioiIUL169dShQwf16tVLlSpVkvS/97lq1apZ1q1WrZrWrVvn0Obr6+sw9E66+v7lp/C82fFgVr+ZfWf266rP1vWye18yMjL09ttv691339XBgwcdrpXKHLJ4I/l9H26U86CgIB06dEgeHh5ZYr92hsT8unjxoiTZfwflNyeSdPjwYY0dO1bffPNNllycP39eUu4+02b9DgJuNYorwE28vb3VoEEDNWjQQHfccYeio6O1YMECxcXF5Xgx7o0uWL/+r7KSVKZMGTVv3lzz58/Xiy++qI0bN+rw4cO5mnGvW7duev/997V06VJ16tRJ8+fPV7Vq1Rxmlfrss8/Up08fderUSc8//7xKlSolT09PTZw40eFsWW5Vq1ZNP/30k/766y9FRETcdPkb5en6swdS9jmSrp69evXVV3Xq1CkFBgbqm2++Uffu3e3TJ2dOU//kk09muTYr07WzlrlKTvHnRXb5kWS/xilznz/99NNsCxhXTi2d3X4OHTpUHTt21OLFi7V8+XKNGTNGEydO1KpVq1SnTp08b6tcuXI5Fn+ZORg+fLj92rvrXf9FN7vYH3/8cTVv3lxfffWVVqxYoTfeeEOvv/66Fi1alKcZCXN67/LjZseDq/q9VZ+t7N6X1157TWPGjNFTTz2lCRMm2K8FHDp0aK5uTZHf98FVOXfGr7/+qlKlStkLlfzmJD09XW3bttWZM2f0wgsvqFq1aipWrJiOHDmiPn36OPRxs8+0O38HAfnBkQkUAPXr15ckHTt2TNL//oJ5/Y05s5v572a6du2qgQMHas+ePYqPj5e/v786dux40/XuvfdelS5dWvHx8WrWrJlWrVplnygg05dffqlKlSpp0aJFDoVOXFyc03FKUseOHfX555/rs88+06hRo266fIkSJbK9eemhQ4fsZwVyo2vXrho/frwWLlyosLAwJSUlOdz7JTQ0VIGBgUpPT3f6LMyNREZG6vvvv9eFCxcczl79/vvv9tfzKr+zZWUO5SpVqpSp+5wflStX1nPPPafnnntOe/fuVe3atTVlyhR99tlnkvK/z9fLPIasVmu+c1C6dGkNHDhQAwcO1IkTJ1S3bl29+uqrat++vf193rNnT5a/0u/Zsydfx4Gr5Tfnrvps5caXX36p++67T7NmzXJoP3funH1yDneKjIxURkaGDh48qCpVqtjbbzaLY25t2LBB+/fvd5imPbc5yel9/+WXX/THH39ozpw56tWrl7392kkzrnWjz7Qzv4OYHRAFCddcAbfQ6tWrs/2r5HfffSfpf8OCgoKCFBISoh9++MFhuXfffdfpbXbp0kWenp76/PPPtWDBAj344IO5uveOh4eHHn30Uf3nP//Rp59+qrS0tCxDAjP/8nrtPm3atEkbNmxwOk5JevTRR1WjRg29+uqr2fZx4cIFhwKvcuXK2rhxo1JTU+1t3377rf766y+ntnvnnXeqRo0aio+PV3x8vEqXLq17773X/rqnp6e6dOmihQsX6tdff82yfnZTmOdGhw4dlJ6ern//+98O7W+99ZYsFku+7rNUrFixbAvP3IqKilJQUJBee+01h+GemfK6z3mRnJysK1euOLRVrlxZgYGBSklJsbfld5+vV6pUKbVs2VLvv/++/Q8f18pNDtLT0+1Doa7tt0yZMvbY69evr1KlSmnmzJkO+7N06VLt3r3btNnhXCHzd0le8+6qz1Zut3397+MFCxZkuY7OXTLPll7/e3/69On57vvQoUPq06ePvL29HWaTzW1Ocnrfs/s/wTAMvf322w7L5eYz7czvoPweh4CZOHMF3EKDBw9WcnKyOnfurGrVqik1NVXr169XfHy8KlSo4HBvqaefflqTJk3S008/rfr16+uHH37QH3/84fQ2S5Uqpfvuu09Tp07VhQsXshRIN9K1a1dNnz5dcXFxqlGjhv1aoEwPPvigFi1apM6dO+uBBx7QwYMHNXPmTFWvXt0+lt8ZVqtVixYtUps2bXTvvffq8ccf1z333COr1arffvtN8+bNU4kSJez3unr66af15Zdf6v7779fjjz+u/fv3O/zF0xldu3bV2LFj5evrq759+2aZKnzSpElavXq1GjVqpH79+ql69eo6c+aMtm/fru+//15nzpxxepsdO3bUfffdp5deekl//vmnatWqpRUrVujrr7/W0KFD87QfmerVq6f33ntPr7zyim6//XaVKlUqx2sXshMUFKT33ntPPXv2VN26ddWtWzeFhobq8OHDWrJkie65554sRaGr/PHHH2rdurUef/xxVa9eXV5eXvrqq6+UmJjocIYxv/ucnRkzZqhZs2aqUaOG+vXrp0qVKikxMVEbNmzQ33//neWeSNe7cOGCypUrp0cffVS1atVSQECAvv/+e23ZskVTpkyRdPW4f/311xUdHa0WLVqoe/fu9qnYK1SooGHDhuVrH1ypXr16kqSXXnpJ3bp1k9VqVceOHZ26ebIrPlu58eCDD+rll19WdHS0mjZtql9++UVz58516qy3K9WrV09dunTRtGnTdPr0aftU7Jn/D+T2bM327dv12WefKSMjQ+fOndOWLVu0cOFCWSwWffrppw7DLnObk8qV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OnSoQkJCFBUVpR49eqhr164O69lsNoWEhOiTTz6RdHUq94kTJ6pixYry8/NTrVq19OWXX+Z6H/LKrfe5+uGHH/TGG29o27ZtOnbsmL766qssCb7emjVrFBsbq99++00REREaPXq0+vTp47DMjBkz9MYbb+j48eOqVauWpk+froYNG7puRwAAAHDLXbalq/rY5W7Z9q/j2uZquYCAAAUEBGjx4sVq3LixfHx88rXdkSNH6s0331SlSpVUokQJffDBB5o7d64mTJhgX2bu3Lnq0aNHlnWDgoL04IMPat68eWrfvr3D8p06dZK/v78kKTAwUB9//LHKlCmjX375Rf369VNgYKBGjBiRqxjnzp2rgIAADRw4MNvXixcv7sQeS3PmzNGAAQPswyj37dunxx57zH6TYUlavny5kpOT1blzZ0nSxIkT9dlnn2nmzJmqUqWKfvjhBz355JMKDQ1VixYtnNq+M9x65urSpUuqVauWZsyYkavlDx48qAceeED33XefduzYoaFDh+rpp5/W8uX/+1DFx8crNjZWcXFx2r59u2rVqqWoqCidOHHCVbsBAAAAZMvLy0sff/yx5syZo+LFi+uee+7Riy++qJ9//jlP/b388stq27atKleurJIlS+qJJ57Q559/bn/9jz/+0LZt2/TEE09ku/4TTzyhxYsX289SJSUlacmSJQ7Ljx492n62qWPHjho+fLjmz5+f6xj37t2rSpUqyWq15mkfr1elShVNnjxZVatWVdWqVRUVFaVixYrpq6++si8zb948PfTQQwoMDFRKSopee+01zZ49W1FRUapUqZL69OmjJ598Uu+//74pMeXErWeu2rdv71A138zMmTNVsWJFTZkyRZJ05513at26dXrrrbcUFRUlSZo6dar69eun6Oho+zpLlizR7NmzNXLkSPN3woUyT3WnpEvJqWmyGvkbK+tn9eSmewAAoMjws3pq18tRbtm2j6dFF67kbtkuXbrogQce0I8//qiNGzdq6dKlmjx5sj788MMsI7Bupn79+g7Pu3XrpuHDh2vjxo1q3Lix5s6dq7p166patWrZrt+hQwdZrVZ988036tatmxYuXKigoCC1adPGvkx8fLzeeecd7d+/XxcvXlRaWpqCgoJyHWNuh0zmVr169Ryee3l56fHHH9fcuXPVs2dPXbp0SV9//bW++OILSVfPbCUnJ6ttW8ezi6mpqapTp46psV3PrcWVszZs2ODwxktSVFSUhg4dKulqwrZt26ZRo0bZX/fw8FCbNm20YcOGHPtNSUlRSkqK/XlSUpKkq2M3nRlfarbk1DTVmrBKkpdGbF6V7/7qlS+uz59uQIF1jcz3153vc1FGfl2L/LoeOXYt8utaRTG/NptNhmEoIyNDGRkZkiRfL/cMxMosIDLjuRlvb2+1bt1arVu31ksvvaR+/fopLi5OvXr1si+Tnp5u7yvzu2nmvma2+/n5OWyvVKlSuu+++zR37lw1bNhQ8+bNU//+/e3LXPtvRkaGvLy81KVLF82dO9deoDz++OPy8PBQRkaGNmzYoCeeeELjxo1Tu3btFBwcrPj4eE2dOtXeV+a+57TfVapU0bp165SSknLDs1cWi8Vh36T/TVhxbX79/f2zbKt79+667777dPz4cSUkJMjPz0/t2rVTRkaG/bv8f/7zH5UtW9ZhPR8fn2zjzsjIkGEYstls8vT0dHjNmc9QoSqujh8/rrCwMIe2sLAwJSUl6fLlyzp79qzS09OzXeb6C/2uNXHiRI0fPz5L+4oVK+xjT90hJV0y8y3advicFn+7VD6eN1/2nyYhIcHdIRRp5Ne1yK/rkWPXIr+uVZTy6+XlpfDwcF28eLHAzBp34cKFPK1XqVIlXbx4UUlJSfbrsPbv32+fiGL9+vWSpOTkZCUlJdmH8V24cEEeHo4F5SOPPKK4uDh17NhRBw4cUIcOHewFRnbrderUSZ07d9amTZu0evVqjRw50r786tWrFRERoZiYGHv/+/btk2EY9mVSUlKUnp5uf369hx56SNOnT9dbb72l/v37Z3n9/PnzCg4OVlBQkH7++WeHfrZt2yar1WrPa3p6ulJTU7Ns6+6771bZsmX1ySefKCEhQQ899JAuX76sy5cvq1y5cvLx8dGePXuyPVOVXdypqam6fPmyfvjhhyyzMGbmMDcKVXHlKqNGjVJsbKz9eVJSkiIiItSuXTunToGazTAMtWqVolWrVqlVq1ayWvP2dl1OTVfj19dKkqKi2snfm7c9k81mU0JCgtq2bWvauGD8D/l1LfLreuTYtcivaxXF/F65ckV//fWXAgIC5Ovr69ZYDMPQhQsXFBgYeMNRQadPn1bXrl3Vp08f1axZU4GBgdq6daumT5+uhx9+WEFBQQoKClLjxo3173//W3fddZdOnDihSZMmSZL8/f0VFBTkMNnE9d9Pe/Tooeeee04jRozQfffdp6pVq9pfy269+++/X+Hh4RowYIAqVqyoVq1a2Ze/++679ffff+u7775TgwYN9N1332nJkiWyWCz29X18fOTp6Znj9+RWrVrp+eef1+jRo3X69Gl16tRJZcqU0b59+/T++++rWbNmGjJkiO6//35Nnz5dixcvVpMmTTR37lz9/vvvqlOnjgIDA3XhwgV5enrK29s722098cQT9untV65caV8mKChIzz33nEaPHi0fHx81a9ZM58+f1/r16xUYGGifrfBaV65ckZ+fn+69994sx1ZORWR2CtW37PDwcCUmJjq0JSYmKigoSH5+fvL09JSnp2e2y4SHh+fYr4+PT7Yzt1itVrf/Mgq2WOTjKQUX881zLFZr2jU/W/NcpBVlBeG9LsrIr2uRX9cjx65Ffl2rKOU3PT1dFotFHh4eWc7e3GqZQ8sy48lJUFCQGjVqpLffflv79++XzWZTRESE+vXrpxdffNG+7uzZs9W3b181aNBAVatW1eTJk9WuXTv7vmYul92+BwcHq2PHjpo/f75mz57t8HpO63Xv3l2TJ0/W2LFjHdo7deqkYcOGaciQIUpJSdEDDzygMWPGaNy4cfblMovJG+335MmTVb9+fc2YMUPvv/++MjIyVLlyZT366KPq06ePPDw81L59e40ZM0YjR47UlStX9NRTT6lXr1765Zdf7NuwWCw55vjJJ5/Ua6+9psjISDVv3tyhyH3llVdUqlQpvf766/rXv/6l4sWLq27dug45v5aHh4csFku2nxdnPj8Ww+wrzvLIYrHcdCr2F154Qd99951++eUXe1uPHj105swZLVu2TJLUqFEjNWzYUNOnT5d09cAvX768YmJicj2hRVJSkoKDg3X+/Hm3nrmSrv7V6bvvvrNffJgXyalp9mlKd70cxZmra5iRX+SM/LoW+XU9cuxa5Ne1imJ+r1y5ooMHD6pixYpuP3OVeW1PUFCQ2wu9ouhW5/dGx5YztYFbj4SLFy9qx44d9humHTx4UDt27NDhw4clXR2ud+1Ffv3799eBAwc0YsQI/f7773r33Xc1f/58DRs2zL5MbGysPvjgA82ZM0e7d+/WgAEDdOnSJfvsgQAAAADgCm49hbF161bdd9999ueZ1z317t1bH3/8sY4dO2Yv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RbWTv7f7vwIUpfwWROTXtcivaxWk/GaOassNt/1mDQkJkaenpxITEx3aExMTFR4enu06oaGhWrx4sa5cuaLTp0+rTJkyGjlypCpVqpTnPiXJx8dHPj4+WdqtVqvb38xMBSmWooj8uhb5dS3y63pFIcdWw/K/n61WWa3uL64yFYX8FmTk17XIr2sVhPw6s323TWjh7e2tevXqaeXKlfa2jIwMrVy5Uk2aNLnhur6+vipbtqzS0tK0cOFCPfzww/nuEwAAAADyw61/toqNjVXv3r1Vv359NWzYUNOmTdOlS5cUHR0tSerVq5fKli2riRMnSpI2bdqkI0eOqHbt2jpy5IjGjRunjIwMjRgxItd9AgAAAIAruLW46tq1q06ePKmxY8fq+PHjql27tpYtW2afkOLw4cPy8PjfybUrV65o9OjROnDggAICAtShQwd9+umnKl68eK77BAAAAABXcPuA65iYGMXExGT72po1axyet2jRQrt27cpXnwAAAADgCm69iTAAAAAAFBUUVwAAAABgAoorAAAAADABxRUAAAAAmIDiCgAAAABMQHEFAAAAACaguAIAAAAAE1BcAQAAAIAJKK4AAAAAwAQUVwAAAABgAoorAAAAADABxRUAAAAAmIDiCgAAAABMQHEFAAAAACZwurhq0aKFPvnkE12+fNkV8QAAAABAoeR0cVWnTh0NHz5c4eHh6tevnzZu3OiKuAAAAACgUHG6uJo2bZqOHj2qjz76SCdOnNC9996r6tWr680331RiYqIrYgQAAACAAi9P11x5eXnpkUce0ddff62///5bPXr00JgxYxQREaFOnTpp1apVZscJAABMkpyaruTUtHw9DMNw924AQIHjlZ+VN2/erI8++khffPGFSpUqpT59+ujIkSN68MEHNXDgQL355ptmxQkAAExS/5Xv899HZAkt6N9EFovFhIgAoGhw+szViRMnNGXKFN19991q3ry5Tp48qc8//1x//vmnxo8frw8//FArVqzQzJkzXREvAADIAz+rp+pHljCtv62HzuqyLd20/gCgKHD6zFW5cuVUuXJlPfXUU+rTp49CQ0OzLFOzZk01aNDAlAABAED+WSwWLejfJN8FUXJquilnvgCgKHK6uFq5cqWaN29+w2WCgoK0evXqPAcFAADMZ7FY5O+drysCAAA34PSwwLi4OJ07dy5Le1JS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1ePVarUaCxYssC+ze/duQ5KxYcMGd4VZaF2fX8MwjBYtWhjPPvus+4IqYkqUKGF8+OGHHLsukplfw+DYNcuFCxeMKlWqGAkJCQ45LYzHMGeuCqjU1FRt27ZNbdq0sbd5eHioTZs22rBhgxsjKzr27t2rMmXKqFKlSnriiSd0+PBhd4dUJB08eFDHjx93OJaDg4PVqFEjjmUTrVmzRqVKlVLVqlU1YMAAnT592t0hFVrnz5+XJJUsWVKStG3bNtlsNodjuFq1aipfvjzHcB5cn99Mc+fOVUhIiO6++26NGjVKycnJ7givUEtPT9cXX3yhS5cuqUmTJhy7Jrs+v5k4dvNv0KBBeuCBBxyOValw/v71cncAyN6pU6eUnp6usLAwh/awsDD9/vvvboqq6GjUqJE+/vhjVa1aVceOHdP48ePVvHlz/frrrwoMDHR3eEXK8ePHJSnbYznzNeTP/fffr0ceeUQVK1bU/v379eKLL6p9+/basGGDPD093R1eoZKRkaGhQ4fqnnvu0d133y3p6jHs7e2t4sWLOyzLMey87PIrST169FBkZKTKlCmjn3/+WS+88IL27NmjRYsWuTHawuOXX35RkyZNdOXKFQUEBOirr75S9erVtWPHDo5dE+SUX4lj1wxffPGFtm/fri1btmR5rTD+/qW4wj9S+/bt7T/XrFlTjRo1UmRkpObPn6++ffu6MTLAed26dbP/XKNGDdWsWVOVK1fWmjVr1Lp1azdGVvgMGjRIv/76K9dgukhO+X3mmWfsP9eoUUOlS5dW69attX//flWuXPlWh1noVK1aVTt27ND58+f15Zdfqnfv3lq7dq27wyoycspv9erVOXbz6a+//tKzzz6rhIQE+fr6ujscUzAssIAKCQmRp6dnltlQEhMTFR4e7qaoiq7ixYvrjjvu0L59+9wdSpGTebxyLN86lSpVUkhICMezk2JiYvTtt99q9erVKleunL09PDxcqampOnfunMPyHMPOySm/2WnUqJEkcQznkre3t26//XbVq1dPEydOVK1atfT2229z7Jokp/xmh2PXOdu2bdOJEydUt25deXl5ycvLS2vXrtU777wjLy8vhYWFFbpjmOKqgPL29la9evW0cuVKe1tGRoZWrlzpMM4X5rh48aL279+v0qVLuzuUIqdixYoKDw93OJaTkpK0adMmjmUX+fvvv3X6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",
            "text/plain": [
              "<Figure size 1000x600 with 1 Axes>"
            ]
          },
          "metadata": {},
          "output_type": "display_data"
        }
      ],
      "source": [
        "# Get the survival function for the first person in the training dataset\n",
        "survival_function = optimal_model.predict_survival_function(person)\n",
        "\n",
        "# Plot the survival curve\n",
        "plt.figure(figsize=(10, 6))\n",
        "for fn in survival_function:\n",
        "    plt.step(fn.x, fn.y, where=\"post\", label=\"Survival Curve\")\n",
        "\n",
        "plt.title(\"Survival Curve for the First Person in the Training Dataset\")\n",
        "plt.xlabel(\"Time (Years at Company)\")\n",
        "plt.ylabel(\"Survival Probability\")\n",
        "plt.grid(True)\n",
        "plt.legend()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "# Verbesserung des PerformanceRatings\n",
        "\n",
        "Im folgenden Modell versuchen wir herauszufinden, wie man neben der Zeit im Unternehmen auch die Performance der Angestellten erh√∂hen kann."
      ],
      "metadata": {
        "id": "JDuMM8tJV-Wk"
      },
      "id": "JDuMM8tJV-Wk"
    },
    {
      "cell_type": "code",
      "source": [
        "#Explorative Analyse der Variablen\n",
        "\n",
        "# Korrelation von numerischen Variablen\n",
        "numerical_features = df.select_dtypes(include=['int64', 'float64'])\n",
        "correlation_matrix = numerical_features.corr()\n",
        "\n",
        "# Visualisierung\n",
        "plt.figure(figsize=(10, 8))\n",
        "sns.heatmap(correlation_matrix, annot=True, fmt=\".2f\", cmap=\"coolwarm\")\n",
        "plt.title(\"Korrelationsmatrix der numerischen Features\")\n",
        "plt.show()\n",
        "\n",
        "\n",
        "# Beispiel: Verteilung von Attrition nach PerformanceRating\n",
        "sns.countplot(data=df, x='PerformanceRating', hue='Attrition')\n",
        "plt.title(\"Verteilung von Attrition nach PerfromanceRating\")\n",
        "plt.xticks(rotation=45)\n",
        "plt.show()\n"
      ],
      "metadata": {
        "id": "xJJJNdPS8ano"
      },
      "id": "xJJJNdPS8ano",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# Regressionsmodell f√ºr performanceRating\n",
        "\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\n",
        "\n",
        "# Zielvariablen\n",
        "X = df.drop(['PerformanceRating'], axis =1)\n",
        "y_performance = df['PerformanceRating']\n",
        "\n",
        "# Daten aufteilen (z. B. f√ºr PerformanceRating)\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y_performance, test_size=0.3, random_state=42)\n",
        "\n",
        "# Modell f√ºr Performance trainieren (z. B. Random Forest Regressor)\n",
        "regressor = RandomForestRegressor(random_state=42)\n",
        "regressor.fit(X_train, y_train)\n",
        "\n",
        "# Feature-Importanz\n",
        "importances = regressor.feature_importances_\n",
        "features = X.columns\n",
        "\n",
        "# Visualisierung\n",
        "sns.barplot(x=importances, y=features)\n",
        "plt.title(\"Feature-Importanz f√ºr PerformanceRating\")\n",
        "plt.show()"
      ],
      "metadata": {
        "id": "Yr3aVtHKV9He"
      },
      "id": "Yr3aVtHKV9He",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "#Das Modell soll zeigen wie performanceRating durch percentsalaryhike vorhergesagt wird.\n",
        "\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.ensemble import RandomForestRegressor\n",
        "import pandas as pd\n",
        "from sklearn.metrics import mean_squared_error, r2_score\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# Angenommen, df ist dein DataFrame und PerformanceRating ist die Zielvariable\n",
        "X = df[['PercentSalaryHike']]\n",
        "y = df['PerformanceRating']\n",
        "\n",
        "# Aufteilen der Daten in Trainings- und Testdaten\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n",
        "\n",
        "# Modell trainieren\n",
        "model = RandomForestRegressor(random_state=42)\n",
        "model.fit(X_train, y_train)\n",
        "\n",
        "# Vorhersage\n",
        "predictions = model.predict(X_test)\n",
        "\n",
        "# Modellbewertung\n",
        "mse = mean_squared_error(y_test, predictions)  # Mean Squared Error\n",
        "r2 = r2_score(y_test, predictions)  # R¬≤-Wert\n",
        "\n",
        "# Ausgabe der Modellbewertung\n",
        "print(f\"Mean Squared Error: {mse}\")\n",
        "print(f\"R¬≤-Wert: {r2}\")\n",
        "\n",
        "# Visualisierung der Vorhersagen vs. tats√§chliche Werte\n",
        "plt.scatter(X_test, y_test, color='blue', label='Tats√§chliche Werte')\n",
        "plt.scatter(X_test, predictions, color='red', label='Vorhergesagte Werte')\n",
        "plt.xlabel('Percent Salary Hike')\n",
        "plt.ylabel('Performance Rating')\n",
        "plt.title('Vorhersage von Performance Rating durch Percent Salary Hike')\n",
        "plt.legend()\n",
        "plt.show()\n",
        "\n",
        "# Feature-Importanz anzeigen\n",
        "importances = model.feature_importances_\n",
        "print(\"Feature Importances: \", importances)\n",
        "\n",
        "\n",
        "# Funktion, die die Vorhersage f√ºr ein bestimmtes percentsalaryhike berechnet\n",
        "def predict_performance_rating(salary_hike):\n",
        "    return model.predict([[salary_hike]])[0]\n",
        "\n",
        "# Optimierung: Findet den percentsalaryhike, der PerformanceRating 4 erreicht\n",
        "def find_salary_hike_for_rating(target_rating):\n",
        "    low, high = 0, 100  # Annahme, dass der percentsalaryhike zwischen 0 und 100 liegt\n",
        "    tolerance = 0.01\n",
        "\n",
        "    while high - low > tolerance:\n",
        "        mid = (low + high) / 2\n",
        "        predicted_rating = predict_performance_rating(mid)\n",
        "\n",
        "        if predicted_rating < target_rating:\n",
        "            low = mid\n",
        "        else:\n",
        "            high = mid\n",
        "\n",
        "    return (low + high) / 2\n",
        "\n",
        "# Finde den percentsalaryhike, der PerformanceRating 4 ergibt\n",
        "required_salary_hike = find_salary_hike_for_rating(4)\n",
        "print(f\"Der erforderliche Salary Hike f√ºr PerformanceRating 4 ist: {required_salary_hike}\")\n"
      ],
      "metadata": {
        "id": "4EyXCvPLk3Zp"
      },
      "id": "4EyXCvPLk3Zp",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3 (ipykernel)",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.10.14"
    },
    "colab": {
      "provenance": [],
      "include_colab_link": true
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}